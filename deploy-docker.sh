#!/usr/bin/env bash
set -euo pipefail

err() { echo "[ERROR] $*" >&2; }
info() { echo "[INFO]  $*" >&2; }

as_root() {
  # Run a command as root (uses sudo if not already root).
  if [[ "${EUID:-$(id -u)}" -ne 0 ]] && command -v sudo >/dev/null 2>&1; then
    sudo "$@"
  else
    "$@"
  fi
}

get_ngrok_https_url() {
  # Best-effort: read the public HTTPS URL from the local ngrok API.
  # Returns 0 and prints the URL if available; otherwise returns non-zero.
  python3 - <<'PY'
import json
import sys
import urllib.request

try:
    with urllib.request.urlopen("http://127.0.0.1:4040/api/tunnels", timeout=2) as resp:
        data = json.load(resp)
except Exception:
    sys.exit(1)

for t in (data.get("tunnels") or []):
    u = (t.get("public_url") or "").strip()
    if u.startswith("https://"):
        print(u)
        sys.exit(0)

sys.exit(2)
PY
}

read_env_kv() {
  # read_env_kv KEY /path/to/env -> prints value or empty
  local key="${1:?}" file="${2:?}" line
  [[ -f "$file" ]] || return 0
  while IFS= read -r line || [[ -n "$line" ]]; do
    [[ "$line" =~ ^[[:space:]]*# ]] && continue
    [[ "$line" =~ ^[[:space:]]*$ ]] && continue
    if [[ "$line" == "${key}="* ]]; then
      printf '%s' "${line#${key}=}"
      return 0
    fi
  done < "$file"
}

sanitize_env_value() {
  # Trim whitespace and strip one layer of surrounding quotes.
  # Useful because docker compose env files treat quotes as literal characters.
  local v
  v="$(printf '%s' "${1:-}" | xargs || true)"
  if [[ "$v" == \"*\" && "$v" == *\" ]]; then
    v="${v#\"}"; v="${v%\"}"
  elif [[ "$v" == \'*\' && "$v" == *\' ]]; then
    v="${v#\'}"; v="${v%\'}"
  fi
  printf '%s' "$v"
}

is_truthy() {
  # Returns 0 if value looks like "true/1/yes/on" (case-insensitive).
  local v
  v="$(printf '%s' "${1:-}" | tr '[:upper:]' '[:lower:]' | xargs)"
  [[ "$v" == "true" || "$v" == "1" || "$v" == "yes" || "$v" == "y" || "$v" == "on" ]]
}

ensure_secret_key_in_env_file() {
  # If SECRET_KEY is missing/blank, generate a strong one and persist it to the env file.
  local file="${1:?}"
  local current
  current="$(read_env_kv SECRET_KEY "$file" | xargs || true)"
  if [[ -n "${current}" ]]; then
    return 0
  fi

  local generated
  generated="$(python3 - <<'PY'
import secrets
print(secrets.token_urlsafe(50))
PY
)"

  # Rewrite file to set/insert SECRET_KEY without clobbering comments/formatting.
  python3 - "$file" "$generated" <<'PY'
import sys
from pathlib import Path

path = Path(sys.argv[1])
secret = sys.argv[2].strip()
lines = path.read_text(encoding="utf-8").splitlines(True)

out = []
replaced = False
for line in lines:
    if line.startswith("SECRET_KEY="):
        out.append(f"SECRET_KEY={secret}\n")
        replaced = True
    else:
        out.append(line)

if not replaced:
    # Append a small block at end so it's easy to find.
    if out and not out[-1].endswith("\n"):
        out[-1] = out[-1] + "\n"
    out.append("\n# Auto-generated by deploy-docker.sh (edit if rotating secrets)\n")
    out.append(f"SECRET_KEY={secret}\n")

path.write_text("".join(out), encoding="utf-8")
PY

  info "Generated SECRET_KEY and wrote it to ${file}."
  return 0
}

stop_systemd_if_running() {
  local unit="${1:?}"
  command -v systemctl >/dev/null 2>&1 || return 0
  systemctl list-unit-files "${unit}" >/dev/null 2>&1 || return 0
  systemctl is-active --quiet "${unit}" >/dev/null 2>&1 || return 0

  info "Stopping systemd unit ${unit} (to avoid port conflicts)..."
  as_root systemctl stop "${unit}" || true
}

port_in_use() {
  local port="${1:?}"
  if command -v ss >/dev/null 2>&1; then
    # -H: no header; returns output if a listener exists.
    ss -ltnH "sport = :${port}" 2>/dev/null | awk 'NR==1{found=1} END{exit found?0:1}'
    return $?
  fi
  # Fallback: attempt bind test (slow but reliable).
  python3 - <<PY >/dev/null 2>&1
import socket
port = int("${port}")
s = socket.socket()
try:
    s.bind(("0.0.0.0", port))
    ok = True
except OSError:
    ok = False
finally:
    try: s.close()
    except Exception: pass
raise SystemExit(0 if (not ok) else 1)
PY
}

describe_port_owner() {
  local port="${1:?}"
  if command -v ss >/dev/null 2>&1; then
    as_root ss -ltnp "sport = :${port}" 2>/dev/null || true
  else
    return 0
  fi
}

kill_port_listeners() {
  local port="${1:?}"

  # Best-effort kill of any remaining listeners.
  if command -v fuser >/dev/null 2>&1; then
    info "Attempting to stop any process listening on port ${port}..."
    as_root fuser -k -n tcp "${port}" >/dev/null 2>&1 || true
  fi

  # Fallback: Identify PID via ss/netstat and kill explicitly
  if port_in_use "${port}"; then
     local pids=""
     if command -v ss >/dev/null 2>&1; then
         # Output format: users:(("process",pid=123,fd=4),...)
         # NOTE: when not root, `ss -p` may omit pid info; don't fail the script under pipefail.
         pids="$( { as_root ss -ltnp "sport = :${port}" 2>/dev/null || true; } | { grep -o 'pid=[0-9]*' || true; } | cut -d= -f2 | sort -u | tr '\n' ' ' || true)"
     elif command -v netstat >/dev/null 2>&1; then
         # Output format: 1234/processname
         pids="$( { as_root netstat -ltnp 2>/dev/null || true; } | { grep ":${port} " || true; } | awk '{print $NF}' | cut -d/ -f1 | { grep -E '^[0-9]+$' || true; } | sort -u | tr '\n' ' ' || true)"
     fi
     
     if [[ -n "$pids" ]]; then
         info "Force killing process(es) holding port ${port}: ${pids}"
         as_root kill -9 ${pids} >/dev/null 2>&1 || true
         sleep 1 # Give it a moment to die
     else
         info "Port ${port} is in use but owning PID couldn't be determined (try running with sudo)."
     fi
  fi

  # If still in use and ss is available, show owner to help debugging.
  if port_in_use "${port}"; then
    info "Port ${port} is still in use; current listener(s):"
    describe_port_owner "${port}" >&2 || true
  fi
}

ensure_port_free() {
  local port="${1:?}"

  # Stop the known host-level DICOM receiver if it is running.
  stop_systemd_if_running "noctis-pro-dicom.service"

  # Stop any docker containers (any stack) that already publish the port.
  local ids
  ids="$(docker ps -q --filter "publish=${port}" 2>/dev/null || true)"
  if [[ -n "$ids" ]]; then
    info "Stopping containers publishing port ${port}..."
    docker stop ${ids} >/dev/null 2>&1 || true
  fi

  # If any other host process is holding the port, try to stop it.
  if port_in_use "${port}"; then
    kill_port_listeners "${port}"
  fi

  # Verify we can bind the port (gives a clear error early).
  python3 - <<PY
import socket, sys
port = int("${port}")
s = socket.socket()
try:
    s.bind(("0.0.0.0", port))
except OSError as e:
    print(f"[ERROR] Host port {port} is still in use: {e}", file=sys.stderr)
    sys.exit(3)
finally:
    try:
        s.close()
    except Exception:
        pass
PY
}

usage() {
  cat <<'EOF'
Usage:
  ./deploy-docker.sh
  ./deploy-docker.sh --ngrok

What this does:
- Builds and starts the Noctis Pro stack via docker compose
- Uses named volumes so DB + uploads persist across code updates

Notes:
- DB persistence is in the docker volume "noctis_pgdata"
  Updating code: docker compose up -d --build   (SAFE)
  Destroying DB: docker compose down -v         (DELETES volumes)
EOF
}

want_ngrok=0
while [[ $# -gt 0 ]]; do
  case "$1" in
    --ngrok) want_ngrok=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) err "Unknown arg: $1"; usage; exit 2 ;;
  esac
done

if ! command -v docker >/dev/null 2>&1; then
  err "docker not found. Install Docker Engine + Docker Compose plugin first."
  exit 127
fi

if ! docker compose version >/dev/null 2>&1; then
  err "docker compose plugin not found. Install Docker Compose v2 plugin."
  exit 127
fi

if [[ ! -f ".env.docker" ]]; then
  if [[ -f ".env.docker.example" ]]; then
    info "Creating .env.docker from .env.docker.example (please edit secrets/hosts/ngrok)."
    cp .env.docker.example .env.docker
  else
    err "Missing .env.docker and .env.docker.example."
    exit 2
  fi
fi

debug_val="$(read_env_kv DEBUG .env.docker | xargs || true)"
ensure_secret_key_in_env_file .env.docker
secret_key_val="$(read_env_kv SECRET_KEY .env.docker | xargs || true)"
if ! is_truthy "${debug_val:-False}"; then
  # In production mode (DEBUG=False), Django settings hard-fail if SECRET_KEY is empty/weak.
  if [[ -z "${secret_key_val}" || "${secret_key_val,,}" == "change-me" || "${secret_key_val,,}" == "changeme" || "${secret_key_val}" == django-insecure* ]]; then
    err "SECRET_KEY is required and must be a strong non-default value when DEBUG=False."
    err "Edit .env.docker and set SECRET_KEY to a strong value."
    exit 2
  fi
fi

dicom_port="$(read_env_kv DICOM_PORT .env.docker)"
dicom_port="${dicom_port:-11112}"

web_port="$(read_env_kv WEB_PORT .env.docker)"
web_port="${web_port:-8000}"

info "Cleaning up old compose resources (safe; volumes persist)..."
docker compose down --remove-orphans >/dev/null 2>&1 || true

info "Ensuring host port ${web_port} is available..."
# Stop the known host-level web service if it is running (to avoid port conflicts).
stop_systemd_if_running "noctis-pro.service"
ensure_port_free "${web_port}"

info "Ensuring host port ${dicom_port} is available..."
ensure_port_free "${dicom_port}"

if [[ "$want_ngrok" == "1" ]]; then
  token_raw="$(read_env_kv NGROK_AUTHTOKEN .env.docker || true)"
  token_val="$(sanitize_env_value "${token_raw:-}")"
  if [[ -z "$token_val" || "$token_val" == "your_ngrok_authtoken" ]]; then
    err "NGROK_AUTHTOKEN is required when using --ngrok."
    err "Edit .env.docker and set: NGROK_AUTHTOKEN=your_actual_token (no quotes)."
    err "Then re-run: ./deploy-docker.sh --ngrok"
    exit 2
  fi
  domain_raw="$(read_env_kv NGROK_DOMAIN .env.docker || true)"
  domain_val="$(sanitize_env_value "${domain_raw:-}")"
  if [[ -n "$domain_val" && "$domain_val" == "reserved.ngrok.app" ]]; then
    err "NGROK_DOMAIN is set to the example value 'reserved.ngrok.app'."
    err "If you don't have a reserved domain, delete/comment NGROK_DOMAIN in .env.docker."
    err "If you do, set it to your actual reserved hostname (no quotes)."
    exit 2
  fi

  info "Ensuring host port 4040 is available (ngrok local API)..."
  ensure_port_free "4040"
fi

args=(--env-file .env.docker up -d --build)
if [[ "$want_ngrok" == "1" ]]; then
  args=(--profile ngrok "${args[@]}")
fi

info "Starting containers..."
docker compose "${args[@]}"

info "Running a quick health check (web logs tail)..."
docker compose ps || true
docker compose logs --tail=30 web || true

# Best-effort reachability check from host -> published port (helps catch exited web container).
python3 - <<PY || {
import sys, time, urllib.request
web_port = int("${web_port}")
url = f"http://127.0.0.1:{web_port}/"
deadline = time.time() + 45
last_err = None
while time.time() < deadline:
    try:
        with urllib.request.urlopen(url, timeout=2) as resp:
            # Any HTTP status means the port is reachable.
            sys.exit(0)
    except Exception as e:
        last_err = e
        time.sleep(1)
print(f"[ERROR] Web not reachable at {url} after 45s: {last_err}", file=sys.stderr)
sys.exit(1)
PY
  err "Web did not become reachable on http://localhost:${web_port}"
  err "Most common causes: container exited (check logs) or port not published."
  err "Try: docker compose ps && docker compose logs --tail=200 web"
  exit 3
}

info "Done."
info "Web:   http://localhost:${web_port}"
info "DICOM: <server-ip>:${dicom_port} (AE: NOCTIS_SCP)"
if [[ "$want_ngrok" == "1" ]]; then
  # ngrok allocates the public URL asynchronously; poll the local API briefly.
  ngrok_url=""
  for _ in $(seq 1 60); do
    ngrok_url="$(get_ngrok_https_url 2>/dev/null || true)"
    if [[ -n "$ngrok_url" ]]; then
      break
    fi
    sleep 0.5
  done

  if [[ -n "$ngrok_url" ]]; then
    printf '%s' "$ngrok_url" > .tunnel-url 2>/dev/null || true
    info "Ngrok: ${ngrok_url}"
    info "Ngrok API: http://localhost:4040"
  else
    info "Ngrok: (starting) check: docker compose logs --tail=200 ngrok"
    info "Ngrok API: http://localhost:4040 (should show the public URL once ready)"
  fi
fi
