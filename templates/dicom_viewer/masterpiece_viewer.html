<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token }}">
    <title>Noctis Pro DICOM Viewer - Masterpiece Edition</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    {% load static %}
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{% static 'css/responsive-ui-scaling.css' %}">
    <script src="{% static 'js/masterpiece_3d_reconstruction.js' %}"></script>
    <script src="{% static 'js/vendor/dicomParser.min.js' %}"></script>
    <script src="{% static 'js/dicom-viewer-enhanced.js' %}"></script>
    <style>
        :root {
            --primary-bg: #0a0a0a;
            --secondary-bg: #1a1a1a;
            --card-bg: #252525;
            --header-bg: #333333;
            --border-color: #404040;
            --accent-color: #00d4ff;
            --text-primary: #ffffff;
            --text-secondary: #b3b3b3;
            --text-muted: #666666;
            --success-color: #00ff88;
            --warning-color: #ffaa00;
            --danger-color: #ff4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            /* Use Inter everywhere to avoid OS font-metric differences (Windows vs Linux) */
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background: var(--primary-bg);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
        }

        .viewer-container {
            display: flex;
            height: 100vh;
            width: 100%;
            max-width: 100%;
        }

        /* Left Toolbar */
        .toolbar {
            width: clamp(56px, 6vw, 70px);
            background: linear-gradient(135deg, #2d2d2d, #1a1a1a);
            border-right: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 5px;
            gap: 15px;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.5);
            overflow-y: auto;
        }

        .tool-btn {
            width: 55px;
            height: 55px;
            border: none;
            border-radius: 12px;
            background: linear-gradient(135deg, #404040, #2a2a2a);
            color: #e0e0e0;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .tool-btn:hover {
            background: linear-gradient(135deg, #555, #404040);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        }

        .tool-btn.active {
            background: linear-gradient(135deg, var(--accent-color), #106ebe);
            color: white;
            transform: scale(1.05);
        }

        .tool-btn i {
            font-size: 18px;
            margin-bottom: 4px;
        }

        /* Center Area */
        .center-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #000;
        }

        .top-bar {
            height: 60px;
            background: linear-gradient(135deg, var(--header-bg), #2a2a2a);
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .logo {
            color: var(--accent-color);
            font-weight: bold;
            font-size: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .patient-info {
            color: var(--text-secondary);
            font-size: 12px;
            margin-left: auto;
        }

        .btn {
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .btn:hover {
            background: var(--accent-color);
            color: var(--primary-bg);
        }

        .btn-primary {
            background: var(--accent-color);
            color: var(--primary-bg);
        }

        .btn-primary:hover {
            background: #00b8d4;
        }

        /* Viewport */
        .viewport {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #dicomCanvas {
            border: none;
            cursor: crosshair;
            background: #000;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* MPR Four Window Layout */
        .mpr-container {
            display: none;
            width: 100%;
            height: 100%;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 2px;
            background: #111;
        }

        .mpr-container.active {
            display: grid;
        }
        
        /* MPR maximize: click a pane to show it full-size */
        .mpr-container.maximized {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
        }
        .mpr-container.maximized .mpr-view {
            display: none;
        }
        .mpr-container.maximized .mpr-view.maximized {
            display: block;
            grid-column: 1 / -1;
            grid-row: 1 / -1;
        }
        .mpr-view.is-active {
            outline: 2px solid var(--accent-color);
            outline-offset: -2px;
        }

        .mpr-view {
            position: relative;
            background: #000;
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .mpr-view canvas {
            width: 100% !important;
            height: 100% !important;
            object-fit: contain;
        }

        .mpr-label {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: var(--accent-color);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            z-index: 10;
        }

        /* Overlay Labels */
        .overlay-labels {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.5;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .zoom-info {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Right Panel */
        .right-panel {
            width: clamp(240px, 22vw, 320px);
            background: linear-gradient(135deg, #2d2d2d, #1a1a1a);
            border-left: 2px solid var(--border-color);
            overflow-y: auto;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.5);
            transition: opacity 0.25s ease, transform 0.25s ease;
        }

        .toolbar, .top-bar {
            transition: opacity 0.25s ease, transform 0.25s ease;
        }

        .ui-hidden .toolbar { opacity: 0; transform: translateX(-12px); pointer-events: none; }
        .ui-hidden .top-bar { opacity: 0; transform: translateY(-12px); pointer-events: none; }
        .ui-hidden .right-panel { opacity: 0; transform: translateX(12px); pointer-events: none; }

        .ui-toggle {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 20;
            background: rgba(0,0,0,0.5);
            color: #fff;
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 6px 10px;
            font-size: 11px;
            cursor: pointer;
        }

        .panel-section {
            margin: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }

        .panel-title {
            font-size: 16px;
            font-weight: 600;
            color: #e0e0e0;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .panel-title i {
            color: var(--accent-color);
        }

        /* Enhanced Sliders */
        .slider-group {
            margin-bottom: 20px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .slider-label {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .slider-value {
            font-size: 13px;
            color: var(--accent-color);
            font-weight: 600;
            background: rgba(0, 120, 212, 0.1);
            padding: 2px 8px;
            border-radius: 4px;
        }

        .custom-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--border-color);
            outline: none;
            -webkit-appearance: none;
            position: relative;
        }

        .custom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-color), #106ebe);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 120, 212, 0.4);
            transition: all 0.3s ease;
        }

        .custom-slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 12px rgba(0, 120, 212, 0.6);
        }

        /* Series List */
        .series-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 16px;
        }

        .series-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .series-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(4px);
        }

        .series-item.active {
            background: linear-gradient(135deg, rgba(0, 120, 212, 0.2), rgba(16, 110, 190, 0.1));
            border-color: var(--accent-color);
        }

        .series-title {
            font-size: 13px;
            font-weight: 500;
            color: #e0e0e0;
            margin-bottom: 4px;
        }

        .series-details {
            font-size: 11px;
            color: var(--text-muted);
        }

        /* Preset Buttons */
        .preset-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 12px;
        }

        .preset-btn {
            background: linear-gradient(135deg, #404040, var(--border-color));
            color: #e0e0e0;
            border: none;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .preset-btn:hover {
            background: linear-gradient(135deg, #555, #444);
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
        }

        /* Info Cards */
        .info-card {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 3px solid var(--accent-color);
        }

        .info-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .info-value {
            font-size: 14px;
            color: #e0e0e0;
            font-weight: 500;
        }

        /* Measurements List */
        .measurements-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 8px;
        }

        .measurement-item {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* 3D Reconstruction Controls */
        .recon-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 16px;
        }

        .recon-btn {
            background: linear-gradient(135deg, #6b46c1, #553c9a);
            color: white;
            border: none;
            padding: 12px 8px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .recon-btn:hover {
            background: linear-gradient(135deg, #553c9a, #6b46c1);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(107, 70, 193, 0.4);
        }

        .recon-btn i {
            font-size: 16px;
        }

        /* Loading States */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--accent-color);
            font-size: 18px;
            flex-direction: column;
        }

        .spinner {
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Clear button */
        .clear-btn {
            background: linear-gradient(135deg, var(--danger-color), #b32d00);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
            margin-bottom: 12px;
            transition: all 0.3s ease;
        }

        .clear-btn:hover {
            background: linear-gradient(135deg, #b32d00, var(--danger-color));
            transform: translateY(-1px);
        }

        /* 3D Controls Overlay */
        .controls-3d {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 10px;
            backdrop-filter: blur(10px);
            z-index: 100;
            display: none;
        }

        .control-3d-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            margin: 2px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .control-3d-btn:hover {
            background: rgba(0, 120, 212, 0.3);
            border-color: var(--accent-color);
        }

        /* Toggle Switches */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 24px;
            margin-left: auto;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--border-color);
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--accent-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        /* Bone Reconstruction Settings */
        .bone-settings {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            padding: 12px;
            margin-top: 12px;
        }

        .threshold-group {
            margin-bottom: 12px;
        }

        .threshold-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
        }

        .threshold-value {
            color: var(--accent-color);
            font-weight: bold;
        }

        /* Series quick navigation (helps MPR workflow) */
        .series-nav {
            display: flex;
            gap: 8px;
            margin: 10px 0 12px 0;
        }
        .series-nav .series-nav-btn {
            flex: 1;
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.12);
            background: rgba(0, 0, 0, 0.25);
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
            transition: transform 0.12s ease, background 0.12s ease, border-color 0.12s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .series-nav .series-nav-btn:hover {
            background: rgba(0, 212, 255, 0.12);
            border-color: rgba(0, 212, 255, 0.35);
            transform: translateY(-1px);
        }
        .series-nav .series-nav-btn:disabled {
            opacity: 0.55;
            cursor: not-allowed;
            transform: none;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .viewer-container {
                flex-direction: column;
            }
            
            .toolbar {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: flex-start;
                padding: 5px;
                height: auto;
                min-height: 60px;
                max-height: min(34dvh, 240px);
                overflow-x: hidden;
                overflow-y: auto;
            }
            
            .right-panel {
                width: 100%;
                height: 300px;
                border-left: none;
                border-top: 2px solid var(--border-color);
            }
            
            .tool-btn {
                width: 45px;
                height: 45px;
                margin: 0 2px;
                min-width: 45px;
            }
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--accent-color);
            color: var(--text-primary);
            padding: 12px 16px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 9999;
            font-size: 13px;
            max-width: 300px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            opacity: 0.95;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            border-left-color: var(--success-color);
        }

        .toast.error {
            border-left-color: var(--danger-color);
        }

        .toast.warning {
            border-left-color: var(--warning-color);
        }

        /* NOTE: Removed MPR crosshair rotation UI/overlay (keeps the original crosshair only). */
    </style>
</head>
<body>
    <div class="viewer-container">
        <button class="ui-toggle" onclick="toggleUI()"><i class="fas fa-eye-slash"></i> UI</button>
        <!-- Left Toolbar -->
        <div class="toolbar">
            <button class="tool-btn active" data-tool="windowing" title="Window/Level">
                <i class="fas fa-adjust"></i>
                <span>Window</span>
            </button>
            <button class="tool-btn" data-tool="zoom" title="Zoom">
                <i class="fas fa-search-plus"></i>
                <span>Zoom</span>
            </button>
            <button class="tool-btn" data-tool="pan" title="Pan">
                <i class="fas fa-hand-paper"></i>
                <span>Pan</span>
            </button>
            <button class="tool-btn" data-tool="measure" title="Measure">
                <i class="fas fa-ruler"></i>
                <span>Measure</span>
            </button>
            <button class="tool-btn" data-tool="angle" title="Angle Measurement">
                <i class="fas fa-drafting-compass"></i>
                <span>Angle</span>
            </button>
            <button class="tool-btn" data-tool="area" title="Area Measurement">
                <i class="fas fa-vector-square"></i>
                <span>Area</span>
            </button>
            <button class="tool-btn" data-tool="roi" title="HU ROI (Ellipse)">
                <i class="fas fa-bullseye"></i>
                <span>ROI</span>
            </button>
            <button class="tool-btn" data-tool="annotate" title="Annotate">
                <i class="fas fa-comment"></i>
                <span>Note</span>
            </button>
            <button class="tool-btn" data-tool="crosshair" title="Crosshair">
                <i class="fas fa-crosshairs"></i>
                <span>Cross</span>
            </button>
            <button class="tool-btn" data-tool="magnify" title="Magnifying Glass">
                <i class="fas fa-search"></i>
                <span>Magnify</span>
            </button>
            <button class="tool-btn" data-tool="cine" title="Cine Mode">
                <i class="fas fa-play"></i>
                <span>Cine</span>
            </button>
            <button class="tool-btn" data-tool="invert" title="Invert">
                <i class="fas fa-adjust"></i>
                <span>Invert</span>
            </button>
            <button class="tool-btn" data-tool="rotate" title="Rotate">
                <i class="fas fa-redo"></i>
                <span>Rotate</span>
            </button>
            <button class="tool-btn" data-tool="flip" title="Flip">
                <i class="fas fa-exchange-alt"></i>
                <span>Flip</span>
            </button>
            <button class="tool-btn" data-tool="reset" title="Reset View">
                <i class="fas fa-undo"></i>
                <span>Reset</span>
            </button>
            <button class="tool-btn" data-tool="mpr" title="MPR View">
                <i class="fas fa-th-large"></i>
                <span>MPR</span>
            </button>
            <button class="tool-btn" data-tool="3d" title="3D Reconstruction">
                <i class="fas fa-cube"></i>
                <span>3D</span>
            </button>
            <button class="tool-btn" data-tool="print" title="Print">
                <i class="fas fa-print"></i>
                <span>Print</span>
            </button>
            <button class="tool-btn" data-tool="export" title="Export">
                <i class="fas fa-download"></i>
                <span>Export</span>
            </button>
        </div>

        <!-- (Removed) Crosshair rotate control (MPR only). -->
        <!-- Center Area -->
        <div class="center-area">
            <!-- Top Bar -->
            <div class="top-bar">
                <div class="logo">
                    <i class="fas fa-hospital-symbol"></i>
                    Noctis Pro DICOM Viewer
                </div>
                
                <button class="btn" onclick="window.loadFromLocalFiles()">
                    <i class="fas fa-folder-open"></i> Load Local DICOM
                </button>

                <button class="btn" onclick="loadStudies()">
                    <i class="fas fa-list"></i> Load Studies
                </button>
                
                <select class="btn" id="studySelector" onchange="selectStudy()" style="min-width: 200px;">
                    <option value="">Select a Study</option>
                </select>
                
                <div class="patient-info" id="patientInfo">
                    Patient: - | Study Date: - | Modality: -
                </div>

                <a class="btn" href="{% url 'worklist:dashboard' %}" title="Back to Dashboard">
                    <i class="fas fa-arrow-left"></i> Dashboard
                </a>
                <button class="btn" onclick="toggleUI()" title="Toggle UI Auto Hide">
                    <i class="fas fa-eye-slash"></i> UI
                </button>
            </div>

            <!-- Viewport -->
            <div class="viewport">
                <!-- Single View Canvas -->
                <div class="canvas-container" id="singleView">
                    <canvas id="dicomCanvas"></canvas>
                    <div class="overlay-labels" id="overlayLabels">
                        <div>WW: <span id="windowWidth">400</span></div>
                        <div>WL: <span id="windowLevel">40</span></div>
                        <div>Slice: <span id="currentSlice">1</span>/<span id="totalSlices">1</span></div>
                        <div>HU: <span id="hounsfield">-</span></div>
                    </div>
                    <div class="zoom-info" id="zoomInfo">
                        Zoom: <span id="zoomLevel">100%</span>
                    </div>
                </div>

                <!-- MPR Four Window View -->
                <div class="mpr-container" id="mprView">
                    <div class="mpr-view" data-plane="axial">
                        <div class="mpr-label">Axial</div>
                        <canvas id="axialCanvas"></canvas>
                    </div>
                    <div class="mpr-view" data-plane="sagittal">
                        <div class="mpr-label">Sagittal</div>
                        <canvas id="sagittalCanvas"></canvas>
                    </div>
                    <div class="mpr-view" data-plane="coronal">
                        <div class="mpr-label">Coronal</div>
                        <canvas id="coronalCanvas"></canvas>
                    </div>
                    <div class="mpr-view" data-plane="bone3d">
                        <div class="mpr-label">3D Bone Reconstruction</div>
                        <canvas id="bone3DCanvas"></canvas>
                        <div class="controls-3d" id="controls3D">
                            <button class="control-3d-btn" onclick="reset3DView()">Reset</button>
                            <button class="control-3d-btn" onclick="toggle3DRotation()">Auto Rotate</button>
                            <button class="control-3d-btn" onclick="export3DModel()">Export</button>
                        </div>
                    </div>
                </div>

                <div class="loading" id="loadingIndicator" style="display: none;">
                    <div class="spinner"></div>
                    <div>Processing DICOM data...</div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- Series Selection -->
            <div class="panel-section">
                <div class="panel-title">
                    <i class="fas fa-list"></i>
                    Series
                </div>
                <div class="series-nav">
                    <button class="series-nav-btn" id="prevSeriesBtn" type="button" title="Previous series ([)">
                        <i class="fas fa-chevron-left"></i>
                        Prev
                    </button>
                    <button class="series-nav-btn" id="nextSeriesBtn" type="button" title="Next series (])">
                        Next
                        <i class="fas fa-chevron-right"></i>
                    </button>
                </div>
                <div class="series-list" id="seriesList">
                    <div class="series-item">
                        <div class="series-title">No series loaded</div>
                        <div class="series-details">Load a study first</div>
                    </div>
                </div>
            </div>

            <!-- Window/Level Controls -->
            <div class="panel-section">
                <div class="panel-title">
                    <i class="fas fa-adjust"></i>
                    Window/Level
                </div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <span class="slider-label">Window Width</span>
                        <span class="slider-value" id="wwValue">400</span>
                    </div>
                    <input type="range" class="custom-slider" id="windowWidthSlider" 
                           min="1" max="4000" value="400" oninput="updateWindowWidth(this.value)">
                </div>

                <div class="slider-group">
                    <div class="slider-header">
                        <span class="slider-label">Window Level</span>
                        <span class="slider-value" id="wlValue">40</span>
                    </div>
                    <input type="range" class="custom-slider" id="windowLevelSlider" 
                           min="-1000" max="1000" value="40" oninput="updateWindowLevel(this.value)">
                </div>

                <div class="preset-grid">
                    <button class="preset-btn" onclick="applyPreset('auto')">Auto</button>
                    <button class="preset-btn" onclick="applyPreset('lung')">Lung</button>
                    <button class="preset-btn" onclick="applyPreset('bone')">Bone</button>
                    <button class="preset-btn" onclick="applyPreset('soft')">Soft</button>
                    <button class="preset-btn" onclick="applyPreset('brain')">Brain</button>
                    <button class="preset-btn" onclick="applyPreset('chest')">Chest</button>
                    <button class="preset-btn" onclick="applyPreset('abdomen')">Abdomen</button>
                    <button class="preset-btn" onclick="applyPreset('liver')">Liver</button>
                    <button class="preset-btn" onclick="applyPreset('mediastinum')">Mediastinum</button>
                    <button class="preset-btn" onclick="applyPreset('xray_chest')">XR Chest</button>
                    <button class="preset-btn" onclick="applyPreset('xray_bone')">XR Bone</button>
                    <button class="preset-btn" onclick="applyPreset('mammo')">Mammo</button>
                </div>
            </div>

            <!-- Navigation -->
            <div class="panel-section">
                <div class="panel-title">
                    <i class="fas fa-arrows-alt"></i>
                    Navigation
                </div>
                
                <div class="slider-group">
                    <div class="slider-header">
                        <span class="slider-label">Slice</span>
                        <span class="slider-value" id="sliceValue">1</span>
                    </div>
                    <input type="range" class="custom-slider" id="sliceSlider" 
                           min="0" max="0" value="0" oninput="updateSlice(this.value)">
                </div>

                <div class="slider-group">
                    <div class="slider-header">
                        <span class="slider-label">Zoom</span>
                        <span class="slider-value" id="zoomValue">100%</span>
                    </div>
                    <input type="range" class="custom-slider" id="zoomSlider" 
                           min="25" max="500" value="100" oninput="updateZoom(this.value)">
                </div>
            </div>

            <!-- 3D Reconstruction Controls -->
            <div class="panel-section">
                <div class="panel-title">
                    <i class="fas fa-cube"></i>
                    3D Reconstruction
                </div>
                
                <div class="recon-controls">
                    <button class="recon-btn" onclick="generateMPR()">
                        <i class="fas fa-th-large"></i>
                        <span>MPR</span>
                    </button>
                    <button class="recon-btn" onclick="generateMIP()">
                        <i class="fas fa-compress-arrows-alt"></i>
                        <span>MIP</span>
                    </button>
                </div>

                    <div class="bone-settings">
                    <div class="threshold-group">
                        <div class="threshold-label">
                            <span>Iso Threshold (HU)</span>
                            <span class="threshold-value" id="boneThresholdValue">200</span>
                        </div>
                        <input type="range" class="custom-slider" id="boneThresholdSlider" 
                               min="-1000" max="2000" value="200" oninput="updateBoneThreshold(this.value)">
                    </div>

                    <div class="threshold-group">
                        <div class="threshold-label">
                            <span>Opacity</span>
                            <span class="threshold-value" id="boneOpacityValue">0.8</span>
                        </div>
                        <input type="range" class="custom-slider" id="boneOpacitySlider" 
                               min="0.1" max="1.0" step="0.1" value="0.8" oninput="updateBoneOpacity(this.value)">
                    </div>

                    <div class="slider-header">
                        <span class="slider-label">Smooth Surface</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="smoothToggle" onchange="toggleSmoothing(this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Image Information -->
            <div class="panel-section">
                <div class="panel-title">
                    <i class="fas fa-info-circle"></i>
                    Image Info
                </div>
                
                <div class="info-card">
                    <div class="info-label">Dimensions</div>
                    <div class="info-value" id="imageDimensions">-</div>
                </div>
                
                <div class="info-card">
                    <div class="info-label">Pixel Spacing</div>
                    <div class="info-value" id="pixelSpacing">-</div>
                </div>
                
                <div class="info-card">
                    <div class="info-label">Series</div>
                    <div class="info-value" id="seriesDescription">-</div>
                </div>
                
                <div class="info-card">
                    <div class="info-label">Institution</div>
                    <div class="info-value" id="institutionName">-</div>
                </div>
            </div>

            <!-- Measurements -->
            <div class="panel-section">
                <div class="panel-title">
                    <i class="fas fa-ruler-combined"></i>
                    Measurements
                </div>
                
                <button class="clear-btn" onclick="clearAllMeasurements()">
                    <i class="fas fa-trash"></i> Clear All
                </button>
                
                <div class="measurements-list" id="measurementsList">
                    <div class="measurement-item">
                        No measurements yet. Use the measure tool to add measurements.
                    </div>
                </div>
            </div>

            <!-- Related References -->
            <div class="panel-section">
                <div class="panel-title">
                    <i class="fas fa-book-medical"></i>
                    Related References
                </div>
                <div style="display:flex; gap:6px; margin-bottom:8px;">
                    <input id="refQuery" class="form-control" placeholder="e.g., CT head hemorrhage" style="flex:1;">
                    <button class="btn" onclick="fetchReferences()"><i class="fas fa-search"></i></button>
                </div>
                <div id="referencesList" style="max-height:180px; overflow:auto; font-size:12px; color: var(--text-secondary);">
                    Enter a query or load a study to see suggestions.
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global Variables
        let currentStudy = null;
        let currentSeries = null;
        let studySeriesList = [];
        let currentImageIndex = 0;
        let imageData = [];
        let activeTool = 'windowing';
        let viewMode = 'single'; // 'single' or 'mpr'
        let measurements = [];
        let annotations = [];
        let fabric3DCanvas = null;
        let boneReconstructionData = null;
        
        // Canvas and context
        let canvas, ctx;
        let mprCanvases = {};
        
        // MPR state (per-plane slice index + render mapping info)
        let mprState = {
            counts: { axial: 0, sagittal: 0, coronal: 0 },
            index: { axial: 0, sagittal: 0, coronal: 0 },
            activePlane: 'axial',
            maximizedPlane: null, // 'axial' | 'sagittal' | 'coronal' | 'bone3d' | null
            // Mapping from canvas coords -> underlying PNG pixel coords for HU/ROI
            // { w,h, dx,dy, dw,dh }
            // baseMeta is the "fit to canvas" rect before applying user pan/zoom in MPR
            baseMeta: { axial: null, sagittal: null, coronal: null },
            renderMeta: { axial: null, sagittal: null, coronal: null },
            lastImage: { axial: null, sagittal: null, coronal: null }, // HTMLImageElement (current rendered)
        };
        // Per-plane MPR pan/zoom state (independent for each viewport)
        let mprViewTransform = {
            axial: { zoom: 1.0, panX: 0, panY: 0 },
            sagittal: { zoom: 1.0, panX: 0, panY: 0 },
            coronal: { zoom: 1.0, panX: 0, panY: 0 },
        };
        // MPR drag state (pan/zoom/window/measure/crosshair)
        let _mprDragState = { down: false, plane: null, tool: null, lastX: 0, lastY: 0, wasDragged: false };
        // MPR measurement draft (stored in slice pixel coords for that plane)
        let mprCurrentMeasurement = null; // { type, mode:'mpr', plane, slice, ... }
        // MPR crosshair (volume voxel indices; volume is (z,y,x) so store as {x,y,z}).
        // x = sagittal slice index, y = coronal slice index, z = axial slice index.
        let mprCrosshairVoxel = null;
        // Linked MPR: when crosshair moves, keep all planes synced to the intersection.
        let mprCrosshairSync = true;
        let _mprPlaneAbort = { axial: null, sagittal: null, coronal: null };
        let _mprHUAbort = null;
        let _mprHUTimer = null;

        // Crosshair drag scheduling (keeps UI real-time while batching network refreshes)
        let _mprCrosshairDragRaf = null;
        let _mprCrosshairDragPending = null; // { plane, x, y }
        let _mprSuppressNextClick = false;

        // Progressive MPR quality:
        // - Start in 'fast' so the first 3 images appear quickly.
        // - Upgrade to 'high' asynchronously (no quality compromise in final image).
        let mprQuality = 'fast';

        let _mprSyncTimer = null;
        
        // ROI tool (ellipse) - live draft while dragging
        let roiDraft = null;
        // MPR ROI: capture mouseup/move on window so ROI works even if cursor leaves small panes.
        let _mprRoiCapture = null; // { plane, onMove, onUp }
        
        // Bone 3D renderer (Three.js)
        let bone3D = {
            renderer: null,
            scene: null,
            camera: null,
            mesh: null,
            animRaf: null,
            dragging: false,
            wasDragged: false,
            lastX: 0,
            lastY: 0,
            rotX: 0,
            rotY: 0,
            zoom: 1.0,
            vertices: null,
            faces: null,
        };
        
        // Display parameters
        let windowWidth = 400;
        let windowLevel = 40;
        let zoom = 1.0;
        let panX = 0, panY = 0;
        let inverted = false;
        // Persist user-chosen WW/WL per series (prevents resets while scrolling / switching series).
        let windowingLockedByUser = false;
        let inversionLockedByUser = false;

        const _WINDOWING_STORE_KEY = 'noctis_windowing_v1';
        function _loadWindowingStore() {
            try {
                const raw = localStorage.getItem(_WINDOWING_STORE_KEY);
                const obj = raw ? JSON.parse(raw) : {};
                return (obj && typeof obj === 'object') ? obj : {};
            } catch (e) {
                return {};
            }
        }
        function _saveWindowingStore(obj) {
            try { localStorage.setItem(_WINDOWING_STORE_KEY, JSON.stringify(obj || {})); } catch (e) {}
        }
        function _getSeriesWindowing(seriesId) {
            const store = _loadWindowingStore();
            return store[String(seriesId)] || null;
        }
        function _setSeriesWindowing(seriesId, ww, wl, inv) {
            if (seriesId == null) return;
            const store = _loadWindowingStore();
            store[String(seriesId)] = {
                ww: Number(ww),
                wl: Number(wl),
                inverted: !!inv,
                ts: Date.now()
            };
            _saveWindowingStore(store);
        }
        function _clearSeriesWindowing(seriesId) {
            if (seriesId == null) return;
            const store = _loadWindowingStore();
            delete store[String(seriesId)];
            _saveWindowingStore(store);
        }
        function _restoreSeriesWindowing(seriesId) {
            const s = _getSeriesWindowing(seriesId);
            if (!s) return false;
            const ww = Number(s.ww);
            const wl = Number(s.wl);
            if (Number.isFinite(ww) && ww > 0) windowWidth = Math.round(ww);
            if (Number.isFinite(wl)) windowLevel = Math.round(wl);
            inverted = !!s.inverted;
            windowingLockedByUser = true;
            inversionLockedByUser = true;
            try { updateSliders(); } catch (e) {}
            try { updateOverlayLabels(); } catch (e) {}
            try { updateToolStates(); } catch (e) {}
            return true;
        }
        // Dynamic WL/WW bounds per image (supports CT/MR/CR/DX/MG/etc without hard clamps).
        // { p1, p99, range, wlMin, wlMax, wwMax } (derived from pixel_data sample)
        let currentImageStats = null;
        // Debounce MPR refresh while dragging window/level.
        let _mprRefreshTimer = null;
        // Pixel spacing for real-world measurements (mm). Prefer per-image DICOM tag; fallback to Series field.
        let currentPixelSpacing = null; // { row: number, col: number } | null
        // Rendering pipeline uses an offscreen canvas because putImageData() ignores transforms.
        let _frameCanvas = null;
        let _frameCtx = null;
        let _frameCacheKey = null;
        let _lastRenderMeta = null; // { imgW, imgH, baseScale, rotDeg }
        let crosshair = false;
        let rotation = 0;
        let flipH = false;
        let flipV = false;
        // Crosshair refinement:
        // - Stored in image pixel coordinates (center point)
        // - Has an independent rotation (degrees) to help align misaligned images without rotating the pixels
        let crosshairRotation = 0; // degrees, additional rotation relative to displayed image axes
        let _crosshairRotateDrag = { active: false, startAngle: 0, baseDeg: 0 };
        let _crosshairRotateHover = false;
        let cineMode = false;
        let cineInterval = null;

        // Fallback rendering: if raw pixel decoding isn't available (compressed transfer syntaxes, missing decoders, etc),
        // we can still display images using the server-rendered PNG endpoint.
        // NOTE: In fallback mode, window/level/invert changes trigger a (debounced) server re-render.
        let _serverRendered = { enabled: false, imageId: null, image: null, dataUrl: null, info: null, key: null };
        let _serverRenderRefreshTimer = null;

        // Magnifier tool (overlay canvas)
        let magnifierCanvas = null;
        let magnifierCtx = null;
        const magnifierSize = 180;
        const magnifierZoomFactor = 2.5;

        // 3D Bone Reconstruction variables
        let boneThreshold = 200;
        let boneOpacity = 0.8;
        let smoothSurface = true;
        let autoRotate = false;

        // Window/Level presets (medical-grade defaults).
        // NOTE: "auto" calls the backend estimator for the current image.
        const DIRECTORY_IMPORT_ENABLED = {{ enable_directory_import|yesno:"true,false" }};
        const DESKTOP_LAUNCH_ENABLED = {{ enable_desktop_launch|yesno:"true,false" }};
        const windowPresets = {
            lung: { ww: 1600, wl: -600 },
            bone: { ww: 2000, wl: 300 },
            soft: { ww: 350, wl: 40 },
            brain: { ww: 80, wl: 40 },
            chest: { ww: 400, wl: 40 },
            abdomen: { ww: 350, wl: 50 },
            liver: { ww: 160, wl: 60 },
            mediastinum: { ww: 350, wl: 50 },
            xray_chest: { ww: 2000, wl: 0 },
            xray_bone: { ww: 3000, wl: 500 },
            mammo: { ww: 4000, wl: 2000 },
        };

        function _normalizePixelSpacing(ps) {
            if (!ps) return null;
            try {
                if (Array.isArray(ps)) {
                    const row = parseFloat(ps[0]);
                    const col = parseFloat(ps.length >= 2 ? ps[1] : ps[0]);
                    if (!isFinite(row) || !isFinite(col) || row <= 0 || col <= 0) return null;
                    return { row, col };
                }
                const s = String(ps);
                const parts = s.includes('\\') ? s.split('\\') : (s.includes(',') ? s.split(',') : s.split('x'));
                const row = parseFloat(parts[0]);
                const col = parseFloat(parts.length >= 2 ? parts[1] : parts[0]);
                if (!isFinite(row) || !isFinite(col) || row <= 0 || col <= 0) return null;
                return { row, col };
            } catch {
                return null;
            }
        }

        function _clamp(v, lo, hi) {
            const x = Number(v);
            if (!isFinite(x)) return lo;
            if (x < lo) return lo;
            if (x > hi) return hi;
            return x;
        }

        function _delay(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms));
        }

        function _computeImageStats(pixelData) {
            try {
                if (!pixelData || !pixelData.length) return null;
                const n = pixelData.length >>> 0;
                // Sample up to ~20k points for fast percentiles.
                const target = 20000;
                const step = Math.max(1, Math.floor(n / target));
                const samples = [];
                for (let i = 0; i < n; i += step) {
                    const v = Number(pixelData[i]);
                    if (isFinite(v)) samples.push(v);
                }
                if (samples.length < 64) return null;
                samples.sort((a, b) => a - b);
                const pct = (p) => {
                    const idx = Math.min(samples.length - 1, Math.max(0, Math.floor((p / 100) * (samples.length - 1))));
                    return samples[idx];
                };
                const p1 = pct(1);
                const p99 = pct(99);
                const range = Math.max(1, p99 - p1);
                // Allow WL/WW to move far enough for any modality.
                const wlMin = Math.floor(p1 - range);
                const wlMax = Math.ceil(p99 + range);
                const wwMax = Math.ceil(Math.max(4000, range * 4));
                return { p1, p99, range, wlMin, wlMax, wwMax };
            } catch (e) {
                return null;
            }
        }

        function _applyWindowingBoundsFromStats() {
            if (!currentImageStats) return;
            const wwSlider = document.getElementById('windowWidthSlider');
            const wlSlider = document.getElementById('windowLevelSlider');
            if (!wwSlider || !wlSlider) return;

            wwSlider.min = '1';
            wwSlider.max = String(currentImageStats.wwMax);
            wlSlider.min = String(currentImageStats.wlMin);
            wlSlider.max = String(currentImageStats.wlMax);

            windowWidth = Math.round(_clamp(windowWidth, 1, currentImageStats.wwMax));
            windowLevel = Math.round(_clamp(windowLevel, currentImageStats.wlMin, currentImageStats.wlMax));
        }

        function _scheduleMPRRefresh() {
            if (viewMode !== 'mpr') return;
            if (_mprRefreshTimer) return;
            _mprRefreshTimer = setTimeout(() => {
                _mprRefreshTimer = null;
                generateMPRViews({ refreshBone: false, quiet: true, preserveSlices: true });
            }, 80);
        }

        function getPixelSpacing() {
            // Prefer current slice PixelSpacing (more reliable), then Series field.
            return currentPixelSpacing || _normalizePixelSpacing(currentSeries && currentSeries.pixel_spacing);
        }

        function _currentRenderMeta() {
            return _lastRenderMeta;
        }

        function canvasPointToImagePx(x, y) {
            const m = _currentRenderMeta();
            if (!m) return null;
            const { imgW, imgH, baseScale, rotDeg } = m;
            const rot = ((rotDeg % 360) + 360) % 360;
            const a = rot * Math.PI / 180;
            const cos = Math.cos(a), sin = Math.sin(a);
            const sx = (baseScale * zoom) * (flipH ? -1 : 1);
            const sy = (baseScale * zoom) * (flipV ? -1 : 1);
            if (!sx || !sy) return null;

            // Translate into view space centered at origin (and undo pan)
            let vx = x - (canvas.width / 2 + panX);
            let vy = y - (canvas.height / 2 + panY);

            // Undo rotation: rotate by -a
            const rx = vx * cos + vy * sin;
            const ry = -vx * sin + vy * cos;

            // Undo scale/flip
            const ix0 = rx / sx;
            const iy0 = ry / sy;

            // Back to image pixel coords
            const ix = ix0 + imgW / 2;
            const iy = iy0 + imgH / 2;
            return { x: ix, y: iy };
        }

        function imagePxToCanvasPoint(pt) {
            const m = _currentRenderMeta();
            if (!m || !pt) return null;
            const { imgW, imgH, baseScale, rotDeg } = m;
            const rot = ((rotDeg % 360) + 360) % 360;
            const a = rot * Math.PI / 180;
            const cos = Math.cos(a), sin = Math.sin(a);

            // Image center at origin
            let x = pt.x - imgW / 2;
            let y = pt.y - imgH / 2;

            // Apply scale/flip
            const sx = (baseScale * zoom) * (flipH ? -1 : 1);
            const sy = (baseScale * zoom) * (flipV ? -1 : 1);
            x *= sx;
            y *= sy;

            // Apply rotation
            const rx = x * cos - y * sin;
            const ry = x * sin + y * cos;

            // Translate to canvas space (+ pan)
            return {
                x: rx + (canvas.width / 2 + panX),
                y: ry + (canvas.height / 2 + panY),
            };
        }

        async function fetchReferences(customQuery) {
            try {
                const qInput = document.getElementById('refQuery');
                const base = customQuery || (qInput ? qInput.value.trim() : '');
                let query = base;
                if (!query && currentStudy) {
                    const modality = (currentStudy.modality || '').toString();
                    const bodyPart = (currentStudy.body_part || '').toString();
                    const desc = (currentStudy.description || '').toString();
                    query = [modality, bodyPart, desc].filter(Boolean).join(' ');
                }
                if (!query) {
                    const list = document.getElementById('referencesList');
                    if (list) list.innerHTML = 'Add a query (e.g., "CT brain hemorrhage").';
                    return;
                }
                const url = `/ai/api/references/?q=${encodeURIComponent(query)}`;
                const resp = await fetch(url, { credentials: 'same-origin' });
                if (!resp.ok) throw new Error('Network error');
                const data = await resp.json();
                const list = document.getElementById('referencesList');
                if (list) {
                    if (data.success && data.references && data.references.length) {
                        list.innerHTML = data.references.map(r => `
                            <div style="margin-bottom:6px;">
                                <a href="${r.url}" target="_blank" style="color: var(--accent-color); text-decoration: none;">
                                    <i class="fas fa-external-link-alt"></i> ${r.title}
                                </a>
                            </div>
                        `).join('');
                    } else {
                        list.innerHTML = 'No references found. Try refining your query.';
                    }
                }
            } catch (e) {
                const list = document.getElementById('referencesList');
                if (list) list.innerHTML = 'Failed to load references.';
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initializeViewer();
            setupEventListeners();
            // Auto-hide disabled by default; user can manually toggle UI
            
            // Check if study ID is provided in URL
            const urlParams = new URLSearchParams(window.location.search);
            const studyId = urlParams.get('study');
            
            if (studyId) {
                // Load specific study
                loadSpecificStudy(studyId);
            } else {
                // Load all studies for selection
                loadStudies();
            }
        });

        function initializeViewer() {
            canvas = document.getElementById('dicomCanvas');
            ctx = canvas.getContext('2d');

            setupMagnifier();
            
            // Set canvas size
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Initialize MPR canvases
            mprCanvases = {
                axial: document.getElementById('axialCanvas'),
                sagittal: document.getElementById('sagittalCanvas'),
                coronal: document.getElementById('coronalCanvas'),
                bone3d: document.getElementById('bone3DCanvas')
            };
            
            // Set up 3D canvas for bone reconstruction
            setupBone3DCanvas();
        }

        function setupMagnifier() {
            const host = canvas?.parentElement;
            if (!host) return;
            host.style.position = host.style.position || 'relative';

            magnifierCanvas = document.createElement('canvas');
            magnifierCanvas.id = 'magnifierCanvas';
            magnifierCanvas.width = magnifierSize;
            magnifierCanvas.height = magnifierSize;
            magnifierCanvas.style.cssText = `
                position: absolute;
                left: 12px;
                top: 12px;
                width: ${magnifierSize}px;
                height: ${magnifierSize}px;
                border-radius: 50%;
                border: 2px solid rgba(0, 212, 255, 0.85);
                box-shadow: 0 6px 18px rgba(0,0,0,0.5);
                background: rgba(0,0,0,0.3);
                pointer-events: none;
                z-index: 50;
                display: none;
            `;
            magnifierCtx = magnifierCanvas.getContext('2d');
            host.appendChild(magnifierCanvas);
        }

        // Auto-hide UI
        let uiHideTimer = null;
        let uiManuallyHidden = false;
        function setupUIAutoHide() {
            const container = document.querySelector('.viewer-container');
            const resetTimer = () => {
                if (uiManuallyHidden) return;
                container.classList.remove('ui-hidden');
                if (uiHideTimer) clearTimeout(uiHideTimer);
                uiHideTimer = setTimeout(() => {
                    container.classList.add('ui-hidden');
                }, 2000);
            };
            ['mousemove','mousedown','wheel','keydown','touchstart','touchmove'].forEach(ev => {
                window.addEventListener(ev, resetTimer, { passive: true });
            });
            resetTimer();
        }

        function toggleUI() {
            const container = document.querySelector('.viewer-container');
            if (container.classList.contains('ui-hidden')) {
                container.classList.remove('ui-hidden');
                uiManuallyHidden = false;
            } else {
                container.classList.add('ui-hidden');
                uiManuallyHidden = true;
            }
        }

        function setupBone3DCanvas() {
            const bone3DCanvas = mprCanvases.bone3d;
            // Initialize renderer lazily (only when a mesh is available).
            if (bone3DCanvas) {
                bone3DCanvas.addEventListener('contextmenu', (e) => e.preventDefault());
                // Allow maximizing the 3D pane (without interfering with drag rotation).
                bone3DCanvas.addEventListener('click', (e) => {
                    // If the user was rotating/dragging, suppress any click actions.
                    if (bone3D && bone3D.wasDragged) {
                        bone3D.wasDragged = false;
                        return;
                    }
                    handleMPRClick(e, 'bone3d');
                });
                bone3DCanvas.addEventListener('dblclick', (e) => {
                    if (bone3D && bone3D.wasDragged) {
                        bone3D.wasDragged = false;
                        return;
                    }
                    handleMPRDoubleClick(e, 'bone3d');
                });
            }
        }

        function resizeCanvas() {
            if (!canvas) return;
            const container = canvas.parentElement;
            if (!container) return;

            const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));

            // Some view transitions temporarily hide the container (display:none),
            // which makes clientWidth/clientHeight become 0 and permanently shrinks the canvas.
            // Be resilient: fall back to the viewport size and retry on the next frame.
            let cw = container.clientWidth;
            let ch = container.clientHeight;

            if (!cw || !ch) {
                const r = container.getBoundingClientRect();
                cw = cw || Math.floor(r.width);
                ch = ch || Math.floor(r.height);
            }

            if (!cw || !ch) {
                const vp = document.querySelector('.viewport');
                if (vp) {
                    cw = cw || vp.clientWidth;
                    ch = ch || vp.clientHeight;
                }
            }

            if (!cw || !ch) {
                requestAnimationFrame(() => {
                    try { resizeCanvas(); } catch (e) {}
                });
                return;
            }

            canvas.width = Math.max(2, Math.floor(cw * dpr));
            canvas.height = Math.max(2, Math.floor(ch * dpr));
            canvas.style.width = cw + 'px';
            canvas.style.height = ch + 'px';
            
            // Resize MPR canvases
            Object.values(mprCanvases).forEach(c => {
                if (c && c.parentElement) {
                    const w = c.parentElement.clientWidth;
                    const h = c.parentElement.clientHeight;
                    c.width = Math.floor(w * dpr);
                    c.height = Math.floor(h * dpr);
                    c.style.width = w + 'px';
                    c.style.height = h + 'px';
                }
            });
            
            redrawCurrentImage();
            if (viewMode === 'mpr') {
                // Recompute per-plane render meta after resize (keeps HU/ROI/crosshair aligned).
                ['axial', 'sagittal', 'coronal'].forEach((p) => {
                    try {
                        const c = mprCanvases[p];
                        const img = mprState.lastImage[p];
                        if (!c || !img) return;
                        const iw = img.naturalWidth || img.width;
                        const ih = img.naturalHeight || img.height;
                        const scale = Math.max(0.0001, Math.min(c.width / iw, c.height / ih));
                        const dw = Math.round(iw * scale);
                        const dh = Math.round(ih * scale);
                        const dx = Math.round((c.width - dw) / 2);
                        const dy = Math.round((c.height - dh) / 2);
                        // Update base meta, then redraw applies user pan/zoom and refreshes renderMeta
                        if (mprState.baseMeta) mprState.baseMeta[p] = { w: iw, h: ih, dx, dy, dw, dh };
                        redrawMPRPlane(p);
                    } catch (e) {}
                });
            }
            if (viewMode === 'mpr' && bone3D && bone3D.renderer && bone3D.scene && bone3D.camera) {
                try { renderBoneFrame(); } catch (e) {}
            }
        }

        function setupEventListeners() {
            // Tool button clicks
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.addEventListener('click', function(e) {
                    const tool = this.dataset.tool;
                    handleToolClick(tool, e, this);
                });
            });

            // Series navigation (useful during MPR)
            document.getElementById('prevSeriesBtn')?.addEventListener('click', () => { prevSeries().catch(() => {}); });
            document.getElementById('nextSeriesBtn')?.addEventListener('click', () => { nextSeries().catch(() => {}); });

            // Canvas mouse events
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('contextmenu', (e) => e.preventDefault()); // Prevent default right-click menu
            
            // MPR canvases: click-to-activate/maximize, wheel-to-scroll slices, ROI/HU interactions
            ['axial', 'sagittal', 'coronal'].forEach((plane) => {
                const c = mprCanvases[plane];
                if (!c) return;
                c.addEventListener('mousedown', (e) => handleMPRMouseDown(e, plane));
                c.addEventListener('mousemove', (e) => handleMPRMouseMove(e, plane));
                c.addEventListener('mouseup', (e) => handleMPRMouseUp(e, plane));
                c.addEventListener('wheel', (e) => handleMPRWheel(e, plane), { passive: false });
                c.addEventListener('contextmenu', (e) => e.preventDefault());
                c.addEventListener('click', (e) => handleMPRClick(e, plane));
                c.addEventListener('dblclick', (e) => handleMPRDoubleClick(e, plane));
            });

            // Keyboard shortcuts
            document.addEventListener('keydown', handleKeyDown);

            // (Removed) MPR crosshair rotation slider
        }

        function refreshToolButtonStates(primaryTool = activeTool) {
            // Primary (mutually-exclusive) tools
            const primaryTools = new Set(['windowing', 'zoom', 'pan', 'measure', 'angle', 'area', 'roi', 'annotate', 'magnify']);
            document.querySelectorAll('.tool-btn').forEach(btn => {
                const t = btn.dataset.tool;
                if (primaryTools.has(t)) {
                    btn.classList.toggle('active', t === primaryTool);
                }
            });

            // Toggle tools keep their own state
            const crosshairBtn = document.querySelector('[data-tool="crosshair"]');
            if (crosshairBtn) crosshairBtn.classList.toggle('active', !!crosshair);

            const cineBtn = document.querySelector('[data-tool="cine"]');
            if (cineBtn) cineBtn.classList.toggle('active', !!cineMode);

            const invertBtn = document.querySelector('[data-tool="invert"]');
            if (invertBtn) invertBtn.classList.toggle('active', !!inverted);
        }

        function handleToolClick(tool, event, buttonEl) {
            // Handle specific tools
            switch(tool) {
                case 'reset':
                    resetAllDefaults();
                    break;
                case 'invert':
                    inverted = !inverted;
                    inversionLockedByUser = true;
                    _setSeriesWindowing(currentSeries && currentSeries.id, windowWidth, windowLevel, inverted);
                    redrawCurrentImage();
                    break;
                case 'crosshair':
                    crosshair = !crosshair;
                    if (viewMode === 'mpr') {
                        // In MPR, crosshair is the linked intersection across planes.
                        if (crosshair && !mprCrosshairVoxel) {
                            mprCrosshairVoxel = {
                                x: Math.max(0, Math.min((mprState.counts.sagittal || 1) - 1, mprState.index.sagittal || 0)),
                                y: Math.max(0, Math.min((mprState.counts.coronal || 1) - 1, mprState.index.coronal || 0)),
                                z: Math.max(0, Math.min((mprState.counts.axial || 1) - 1, mprState.index.axial || 0)),
                            };
                        }
                        redrawAllMPRPlanes();
                    } else {
                        // Single view: keep crosshair anchored in image space so it stays correct through pan/zoom/rotate/flip.
                        if (crosshair && (!crosshairImagePx || crosshairImagePx.x == null || crosshairImagePx.y == null)) {
                            const m = _currentRenderMeta();
                            if (m && m.imgW && m.imgH) {
                                crosshairImagePx = { x: m.imgW / 2, y: m.imgH / 2 };
                            } else {
                                // Fallback if no image meta available yet (will render centered).
                                crosshairImagePx = null;
                            }
                        }
                        redrawCurrentImage();
                        if (crosshair) {
                            showToast('Crosshair: drag the small handle to rotate; Alt+Click to reposition', 'info', 3500);
                        }
                    }
                    break;
                case 'rotate':
                    rotation = (rotation + 90) % 360;
                    redrawCurrentImage();
                    break;
                case 'flip':
                    flipH = !flipH;
                    redrawCurrentImage();
                    break;
                case 'cine':
                    toggleCineMode();
                    break;
                case 'mpr':
                    toggleMPRView();
                    break;
                case '3d':
                    toggle3DView();
                    break;
                case 'print':
                    printCurrentImage();
                    break;
                case 'export':
                    exportCurrentImage();
                    break;
                default:
                    activeTool = tool;
                    break;
            }

            refreshToolButtonStates(activeTool);
        }

        function toggleCineMode() {
            cineMode = !cineMode;
            const btn = document.querySelector('[data-tool="cine"]');
            
            if (cineMode) {
                btn.classList.add('active');
                btn.innerHTML = '<i class="fas fa-pause"></i><span>Stop</span>';
                startCine();
            } else {
                btn.classList.remove('active');
                btn.innerHTML = '<i class="fas fa-play"></i><span>Cine</span>';
                stopCine();
            }
        }

        function startCine() {
            if (imageData.length <= 1) return;
            
            cineInterval = setInterval(() => {
                currentImageIndex = (currentImageIndex + 1) % imageData.length;
                document.getElementById('sliceSlider').value = currentImageIndex;
                updateSlice(currentImageIndex);
            }, 200); // 5 FPS
        }

        function stopCine() {
            if (cineInterval) {
                clearInterval(cineInterval);
                cineInterval = null;
            }
        }

        function toggleMPRView() {
            const singleView = document.getElementById('singleView');
            const mprView = document.getElementById('mprView');
            const controls3D = document.getElementById('controls3D');
            
            if (viewMode === 'single') {
                // Don't switch to MPR if there's no series loaded (otherwise panes look "blank").
                if (!currentSeries || currentSeries.id == null) {
                    showToast('Load a series first to use MPR', 'warning');
                    return;
                }
                singleView.style.display = 'none';
                mprView.classList.add('active');
                if (controls3D) controls3D.style.display = 'block';
                viewMode = 'mpr';
                // Ensure canvases have non-zero size now that MPR is visible.
                // Use rAF so layout has applied the new grid before reading client sizes.
                requestAnimationFrame(() => {
                    try { resizeCanvas(); } catch (e) {}
                    setMPRMaximizedPlane(null);
                    setActiveMPRPlane('axial');
                    generateMPRViews({ refreshBone: true, quiet: false, preserveSlices: false });
                });
            } else {
                singleView.style.display = 'block';
                mprView.classList.remove('active');
                if (controls3D) controls3D.style.display = 'none';
                viewMode = 'single';
                autoRotate = false;
                stopBoneAnimationLoop();
                // Coming back from MPR can leave the single-view canvas sized to 0 if the container
                // was hidden during a resize/layout pass. Ensure it's non-zero before redrawing.
                requestAnimationFrame(() => {
                    try { resizeCanvas(); } catch (e) {}
                    try { redrawCurrentImage(); } catch (e) {}
                });
            }
        }

        function toggle3DView() {
            // Ensure the 3D pane is visible, then (re)generate mesh.
            const singleView = document.getElementById('singleView');
            const mprView = document.getElementById('mprView');
            const controls3D = document.getElementById('controls3D');

            if (viewMode === 'single') {
                if (!currentSeries || currentSeries.id == null) {
                    showToast('Load a series first to use 3D', 'warning');
                    return;
                }
                if (singleView) singleView.style.display = 'none';
                if (mprView) mprView.classList.add('active');
                if (controls3D) controls3D.style.display = 'block';
                viewMode = 'mpr';
                // Make the 3D pane the focus for interaction.
                setActiveMPRPlane('bone3d');
                setMPRMaximizedPlane('bone3d');
                requestAnimationFrame(() => {
                    try { resizeCanvas(); } catch (e) {}
                });
            } else {
                setActiveMPRPlane('bone3d');
            }
            generateBoneReconstruction();
        }

        async function loadStudies() {
            try {
                showLoading(true);
                const response = await fetch('/dicom-viewer/api/realtime/studies/');
                const data = await response.json();
                
                const selector = document.getElementById('studySelector');
                selector.innerHTML = '<option value="">Select a Study</option>';
                
                data.studies.forEach(study => {
                    const option = document.createElement('option');
                    option.value = study.id;
                    option.textContent = `${study.patient_name} - ${study.study_date} - ${study.modality}`;
                    selector.appendChild(option);
                });
                
                showLoading(false);
                showToast('Studies loaded successfully', 'success');
            } catch (error) {
                console.error('Error loading studies:', error);
                showToast('Failed to load studies', 'error');
                showLoading(false);
            }
        }

        async function loadSpecificStudy(studyId) {
            try {
                showLoading(true);
                // Load the specific study
                const response = await fetch(`/dicom-viewer/api/study/${studyId}/data/`);
                const data = await response.json();
                
                if (data && data.study && Array.isArray(data.series)) {
                    currentStudy = data.study;
                    displaySeriesList(data.series);
                    updatePatientInfo(currentStudy);
                    // Load related references automatically based on study context
                    try { fetchReferences(); } catch (e) {}
                    
                    // Auto-load the "best" series (largest diagnostic stack) so local uploads
                    // look identical to worklist-opened studies. First series is often a low-res scout/localizer.
                    if (data.series.length > 0) {
                        const best = pickBestSeriesForDisplay(data.series);
                        await loadSeries((best && best.id) ? best.id : data.series[0].id);
                    }
                    
                    showToast(`Loaded study: ${currentStudy.patient_name}`, 'success');
                } else {
                    showToast('Failed to load study', 'error');
                }
                
                showLoading(false);
            } catch (error) {
                console.error('Error loading specific study:', error);
                showToast('Failed to load study', 'error');
                showLoading(false);
            }
        }

        function pickBestSeriesForDisplay(seriesList) {
            try {
                const list = Array.isArray(seriesList) ? seriesList : [];
                if (list.length === 0) return null;

                const badWords = [
                    'LOCALIZER', 'SCOUT', 'SURVEY', 'TOPO', 'TOP0', 'SCANOGRAM',
                    'MPR', '3D', 'VRT', 'VR', 'DERIVED', 'SECONDARY', 'TEST', 'QA'
                ];

                const score = (s) => {
                    const count = Number(s && s.image_count) || 0;
                    const modality = String((s && s.modality) || '').toUpperCase();
                    const desc = String((s && (s.description || s.series_description)) || '').toUpperCase();

                    // Base on stack size (main diagnostic series is usually largest)
                    let v = count;

                    // Prefer cross-sectional modalities for default display
                    if (modality === 'CT') v += 5000;
                    else if (modality === 'MR') v += 4000;
                    else if (modality === 'PT') v += 2000;
                    else if (modality === 'NM') v += 1500;

                    // Penalize obvious non-diagnostic / planning series
                    if (badWords.some(w => desc.includes(w))) v -= 6000;

                    // Prefer thicker stacks over single images (e.g., avoid thumbnails)
                    if (count <= 1) v -= 3000;
                    if (count < 10) v -= 800;

                    return v;
                };

                return list.slice().sort((a, b) => score(b) - score(a))[0] || list[0];
            } catch (e) {
                return (Array.isArray(seriesList) && seriesList[0]) ? seriesList[0] : null;
            }
        }

        async function selectStudy() {
            const studyId = document.getElementById('studySelector').value;
            if (!studyId) return;
            
            await loadSpecificStudy(studyId);
        }

        function displaySeriesList(series) {
            const container = document.getElementById('seriesList');
            container.innerHTML = '';
            studySeriesList = Array.isArray(series) ? series.slice() : [];

            const prevBtn = document.getElementById('prevSeriesBtn');
            const nextBtn = document.getElementById('nextSeriesBtn');
            const hasList = studySeriesList.length > 0;
            if (prevBtn) prevBtn.disabled = !hasList;
            if (nextBtn) nextBtn.disabled = !hasList;
            
            series.forEach((s, index) => {
                const item = document.createElement('div');
                item.className = 'series-item';
                if (index === 0) item.classList.add('active');
                
                item.innerHTML = `
                    <div class="series-title">Series ${s.series_number}: ${s.description}</div>
                    <div class="series-details">${s.modality}  ${s.image_count} images</div>
                `;
                
                item.addEventListener('click', () => {
                    document.querySelectorAll('.series-item').forEach(el => el.classList.remove('active'));
                    item.classList.add('active');
                    loadSeries(s.id);
                });
                
                container.appendChild(item);
            });
        }

        function _setActiveSeriesListItem(seriesId) {
            try {
                const id = Number(seriesId);
                const items = Array.from(document.querySelectorAll('#seriesList .series-item'));
                items.forEach((el) => el.classList.remove('active'));
                const idx = (studySeriesList || []).findIndex((s) => Number(s && s.id) === id);
                if (idx >= 0 && items[idx]) items[idx].classList.add('active');
            } catch (e) {}
        }

        function _abortMPRRequestsAndTimers() {
            try {
                Object.keys(_mprPlaneAbort || {}).forEach((p) => {
                    try { _mprPlaneAbort[p]?.abort?.(); } catch (e) {}
                });
            } catch (e) {}
            try { _mprHUAbort?.abort?.(); } catch (e) {}
            try { if (_mprHUTimer) { clearTimeout(_mprHUTimer); _mprHUTimer = null; } } catch (e) {}
            try { if (_mprSyncTimer) { clearTimeout(_mprSyncTimer); _mprSyncTimer = null; } } catch (e) {}
            try { if (_mprRefreshTimer) { clearTimeout(_mprRefreshTimer); _mprRefreshTimer = null; } } catch (e) {}
        }

        async function loadSeries(seriesId) {
            try {
                showLoading(true);
                _resetServerRendered();
                // Switching series during MPR should not leave stale requests running.
                _abortMPRRequestsAndTimers();
                roiDraft = null;
                if (mprState && mprState.renderMeta) {
                    mprState.renderMeta = { axial: null, sagittal: null, coronal: null };
                }
                // Also clear base meta so new series can't inherit stale fit-to-pane geometry.
                if (mprState && mprState.baseMeta) {
                    mprState.baseMeta = { axial: null, sagittal: null, coronal: null };
                }
                if (mprState && mprState.lastImage) {
                    mprState.lastImage = { axial: null, sagittal: null, coronal: null };
                }
                const response = await fetch(`/dicom-viewer/series/${seriesId}/images/`);
                const data = await response.json();
                
                currentSeries = data.series;
                imageData = data.images;
                currentImageIndex = 0;

                // Restore persisted WW/WL/invert for this series if present.
                // If not present, allow the first loaded slice to set defaults.
                windowingLockedByUser = false;
                inversionLockedByUser = false;
                _restoreSeriesWindowing(currentSeries && currentSeries.id);
                
                // Update UI
                _setActiveSeriesListItem(seriesId);
                document.getElementById('sliceSlider').max = imageData.length - 1;
                document.getElementById('totalSlices').textContent = imageData.length;
                
                updateImageInfo(currentSeries);
                await loadCurrentImage();

                // If already in MPR mode, refresh MPR views for the new series automatically.
                if (viewMode === 'mpr') {
                    try { resizeCanvas(); } catch (e) {}
                    await generateMPRViews({ refreshBone: false, quiet: true, preserveSlices: false });
                    try { generateBoneReconstruction(); } catch (e) {}
                }
                
                showLoading(false);
                showToast(`Loaded ${imageData.length} images`, 'success');
            } catch (error) {
                console.error('Error loading series:', error);
                showToast('Failed to load series', 'error');
                showLoading(false);
            }
        }

        async function nextSeries() {
            if (!Array.isArray(studySeriesList) || studySeriesList.length === 0) return;
            if (!currentSeries || currentSeries.id == null) return;
            const idx = studySeriesList.findIndex((s) => Number(s && s.id) === Number(currentSeries.id));
            const next = idx >= 0 ? studySeriesList[Math.min(studySeriesList.length - 1, idx + 1)] : studySeriesList[0];
            if (next && next.id != null && Number(next.id) !== Number(currentSeries.id)) {
                await loadSeries(next.id);
            }
        }

        async function prevSeries() {
            if (!Array.isArray(studySeriesList) || studySeriesList.length === 0) return;
            if (!currentSeries || currentSeries.id == null) return;
            const idx = studySeriesList.findIndex((s) => Number(s && s.id) === Number(currentSeries.id));
            const prev = idx >= 0 ? studySeriesList[Math.max(0, idx - 1)] : studySeriesList[0];
            if (prev && prev.id != null && Number(prev.id) !== Number(currentSeries.id)) {
                await loadSeries(prev.id);
            }
        }

        // Cache the last loaded image payload so redraws during mousemove don't refetch
        // and cause "spray" artifacts from repeated overlay drawing.
        let lastLoadedImagePayload = null;
        let lastLoadedImageId = null;
        let redrawRaf = null;
        // Performance: in-memory LRU cache + abortable/coalesced loading for smooth scrolling.
        const _IMAGE_PAYLOAD_CACHE_MAX = 24; // keep modest; pixel buffers are large
        const _imagePayloadCache = new Map(); // imageId -> payload (with pixel_data as TypedArray)
        const _imagePayloadCacheOrder = []; // LRU order of imageIds
        let _imageLoadAbortController = null;
        let _imageLoadSeq = 0;
        let _scheduledLoadRaf = null;
        let _scheduledLoadIndex = null;
        let _prefetchTimer = null;

        function _cacheGetPayload(imageId) {
            const key = String(imageId);
            const v = _imagePayloadCache.get(key);
            if (!v) return null;
            const idx = _imagePayloadCacheOrder.indexOf(key);
            if (idx >= 0) {
                _imagePayloadCacheOrder.splice(idx, 1);
                _imagePayloadCacheOrder.push(key);
            }
            return v;
        }

        function _cacheSetPayload(imageId, payload) {
            const key = String(imageId);
            if (!_imagePayloadCache.has(key)) {
                while (_imagePayloadCacheOrder.length >= _IMAGE_PAYLOAD_CACHE_MAX) {
                    const evict = _imagePayloadCacheOrder.shift();
                    if (evict != null) _imagePayloadCache.delete(evict);
                }
                _imagePayloadCacheOrder.push(key);
            } else {
                const idx = _imagePayloadCacheOrder.indexOf(key);
                if (idx >= 0) _imagePayloadCacheOrder.splice(idx, 1);
                _imagePayloadCacheOrder.push(key);
            }
            _imagePayloadCache.set(key, payload);
        }

        function _decodeB64ToFloat32Array(b64) {
            // b64 is a base64-encoded little-endian float32 buffer.
            const binary = atob(b64);
            const len = binary.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
            return new Float32Array(bytes.buffer);
        }

        function _isLittleEndian() {
            try {
                const u32 = new Uint32Array([0x11223344]);
                const u8 = new Uint8Array(u32.buffer);
                return u8[0] === 0x44;
            } catch (_) {
                return true;
            }
        }

        function _decodeArrayBufferToFloat32LE(buf) {
            // Server sends little-endian float32 bytes.
            if (_isLittleEndian()) return new Float32Array(buf);
            // Rare: big-endian client; swap using DataView.
            const dv = new DataView(buf);
            const out = new Float32Array(buf.byteLength / 4);
            for (let i = 0; i < out.length; i++) out[i] = dv.getFloat32(i * 4, true);
            return out;
        }

        function _parseHeaderNum(headers, name) {
            try {
                const v = headers.get(name);
                if (v == null) return null;
                const n = Number(v);
                return Number.isFinite(n) ? n : null;
            } catch (_) {
                return null;
            }
        }

        function _parseHeaderStr(headers, name) {
            try {
                const v = headers.get(name);
                return (v == null) ? null : String(v);
            } catch (_) {
                return null;
            }
        }

        function _parsePixelSpacingHeader(headers) {
            const v = _parseHeaderStr(headers, 'X-Noctis-Pixel-Spacing');
            if (!v) return null;
            // Accept "row,col" or "row\\col"
            const parts = v.includes('\\') ? v.split('\\') : v.split(',');
            if (!parts.length) return null;
            const row = parseFloat(parts[0]);
            const col = parseFloat(parts.length >= 2 ? parts[1] : parts[0]);
            if (!isFinite(row) || !isFinite(col) || row <= 0 || col <= 0) return null;
            return [row, col];
        }

        async function _fetchImagePayloadBinary(imageId, signal) {
            const url = `/dicom-viewer/api/image/${imageId}/data/?packed=bin`;
            const resp = await fetch(url, {
                signal,
                credentials: 'same-origin',
                cache: 'force-cache',
            });
            if (!resp.ok) return null;

            const ct = (resp.headers.get('content-type') || '').toLowerCase();
            // If the server returns JSON here (older backend / error), treat as unsupported and fall back.
            if (ct.includes('application/json')) return null;

            const rows = _parseHeaderNum(resp.headers, 'X-Noctis-Rows');
            const cols = _parseHeaderNum(resp.headers, 'X-Noctis-Columns');
            if (!rows || !cols) return null;

            const ww = _parseHeaderNum(resp.headers, 'X-Noctis-Window-Width');
            const wl = _parseHeaderNum(resp.headers, 'X-Noctis-Window-Center');
            const ps = _parsePixelSpacingHeader(resp.headers);
            const st = _parseHeaderNum(resp.headers, 'X-Noctis-Slice-Thickness');
            const modality = _parseHeaderStr(resp.headers, 'X-Noctis-Modality');

            const buf = await resp.arrayBuffer();
            const pixel_data = _decodeArrayBufferToFloat32LE(buf);

            return {
                id: imageId,
                rows: rows,
                columns: cols,
                window_width: ww != null ? ww : undefined,
                window_center: wl != null ? wl : undefined,
                pixel_spacing: ps != null ? ps : undefined,
                slice_thickness: st != null ? st : undefined,
                modality: modality != null ? modality : undefined,
                pixel_data,
                pixel_data_b64: null,
                pixel_dtype: 'float32',
                pixel_endian: 'little',
            };
        }

        async function _fetchImagePayloadJsonPacked(imageId, signal) {
            const url = `/dicom-viewer/api/image/${imageId}/data/?packed=1`;
            const response = await fetch(url, {
                signal,
                credentials: 'same-origin',
                cache: 'force-cache'
            });
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }
            const data = await response.json();
            if (data && data.pixel_data_b64 && (!data.pixel_data || !data.pixel_data.length)) {
                try {
                    data.pixel_data = _decodeB64ToFloat32Array(data.pixel_data_b64);
                    data.pixel_data_b64 = null; // reduce memory
                } catch (e) {
                    data.pixel_data = null;
                    data.pixel_data_b64 = null;
                    data.warnings = { ...(data.warnings || {}), pixel_decode_error: `Client decode failed: ${e?.message || e}` };
                }
            }
            return data;
        }

        function _resetServerRendered() {
            _serverRendered = { enabled: false, imageId: null, image: null, dataUrl: null, info: null, key: null };
            if (_serverRenderRefreshTimer) {
                try { clearTimeout(_serverRenderRefreshTimer); } catch (e) {}
                _serverRenderRefreshTimer = null;
            }
        }

        function _desiredServerInvertFromInfo(info) {
            try {
                const photo = ((info && (info.photometric_interpretation || info.photometric)) || '').toString().toUpperCase();
                const mono1 = photo === 'MONOCHROME1';
                // Match the client renderer: final inversion is user invert XOR MONOCHROME1.
                return (!!inverted) !== (!!mono1);
            } catch (e) {
                return !!inverted;
            }
        }

        function _serverRenderKey(imageId, info) {
            const inv = _desiredServerInvertFromInfo(info) ? 1 : 0;
            return `${String(imageId)}|ww:${Math.round(Number(windowWidth) || 0)}|wl:${Math.round(Number(windowLevel) || 0)}|inv:${inv}`;
        }

        async function _loadServerRenderedFrame(imageId, { quiet = false } = {}) {
            const id = String(imageId);
            const params = new URLSearchParams();
            // Prefer a lightweight JSON response that returns a PNG URL (streamed bytes),
            // rather than embedding a potentially huge data URL.
            params.set('mode', 'url');

            // Only send WW/WL if we have numeric values; backend can choose sensible defaults if omitted.
            const ww = Number(windowWidth);
            const wl = Number(windowLevel);
            if (Number.isFinite(ww) && Number.isFinite(wl) && ww > 0) {
                params.set('ww', String(ww));
                params.set('wl', String(wl));
            }

            // First pass: omit invert so backend can apply MONOCHROME1 defaults.
            let url = `/dicom-viewer/api/image/${encodeURIComponent(id)}/display/${params.toString() ? `?${params.toString()}` : ''}`;
            let resp = await fetch(url, { credentials: 'same-origin', cache: 'no-store' });
            let data = await resp.json().catch(() => ({}));

            // If we can derive the exact desired inversion from response info, ensure it matches.
            const info = (data && data.image_info) ? data.image_info : null;
            const desiredInvert = _desiredServerInvertFromInfo(info);
            const serverInvert = !!(data && data.windowing && data.windowing.inverted);
            if (info && (serverInvert !== desiredInvert)) {
                const p2 = new URLSearchParams(params.toString());
                p2.set('invert', String(desiredInvert));
                const url2 = `/dicom-viewer/api/image/${encodeURIComponent(id)}/display/?${p2.toString()}`;
                resp = await fetch(url2, { credentials: 'same-origin', cache: 'no-store' });
                data = await resp.json().catch(() => ({}));
            }

            const srcUrl = data && (data.image_url || data.image_data);
            if (!srcUrl || typeof srcUrl !== 'string') {
                const warn = (data && data.warnings) || {};
                const msg =
                    warn.pixel_decode_error ||
                    warn.dicom_read_error ||
                    warn.dicom_open_error ||
                    warn.render_error ||
                    'Server did not return renderable image data';
                throw new Error(msg);
            }

            // Keep WW/WL synced to what backend used (useful when we omitted ww/wl).
            try {
                if (data && data.windowing) {
                    if (Number.isFinite(Number(data.windowing.window_width))) windowWidth = Number(data.windowing.window_width);
                    if (Number.isFinite(Number(data.windowing.window_level))) windowLevel = Number(data.windowing.window_level);
                    updateSliders();
                }
            } catch (e) {}

            const img = new Image();
            try { img.decoding = 'async'; } catch (e) {}
            img.src = srcUrl;
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
            });

            _serverRendered.enabled = true;
            _serverRendered.imageId = id;
            _serverRendered.image = img;
            _serverRendered.dataUrl = srcUrl;
            _serverRendered.info = (data && data.image_info) ? data.image_info : info;
            _serverRendered.key = _serverRenderKey(id, _serverRendered.info);

            if (!quiet) {
                const warn = (data && data.warnings) || {};
                if (warn && (warn.pixel_decode_error || warn.dicom_read_forced || warn.dicom_read_forced_path)) {
                    showToast('Displayed server-rendered image (raw pixel decode unavailable)', 'warning', 3500);
                }
            }

            redrawCurrentImage();
        }

        function _scheduleServerRenderedRefresh(imageId) {
            if (!_serverRendered || !_serverRendered.enabled) return;
            const id = imageId != null ? String(imageId) : null;
            if (!id) return;
            if (_serverRenderRefreshTimer) {
                try { clearTimeout(_serverRenderRefreshTimer); } catch (e) {}
            }
            // Debounce so WW/WL sliders don't spam the server.
            _serverRenderRefreshTimer = setTimeout(() => {
                _serverRenderRefreshTimer = null;
                _loadServerRenderedFrame(id, { quiet: true }).catch(() => {});
            }, 120);
        }

        function _applyLoadedImagePayload(data, imageId) {
            // Update window/level from DICOM data - SAME AS YOUR ORIGINAL
            // Do not overwrite user-selected WW/WL while scrolling.
            if (!windowingLockedByUser) {
                windowWidth = data.window_width || windowWidth;
                windowLevel = data.window_center || windowLevel;
            }

            // Derive WL/WW slider bounds from actual pixel distribution (fast sampled percentiles).
            if (!data.__stats) {
                data.__stats = _computeImageStats(data.pixel_data);
            }
            currentImageStats = data.__stats;
            _applyWindowingBoundsFromStats();

            // Capture per-image PixelSpacing if present (MultiValue -> array). Fallback to Series field.
            if (!data.__pixelSpacing) {
                data.__pixelSpacing = _normalizePixelSpacing(data.pixel_spacing) || _normalizePixelSpacing(currentSeries && currentSeries.pixel_spacing);
            }
            currentPixelSpacing = data.__pixelSpacing;

            // If Series pixel spacing is missing but the image has it, promote it for UI/measurements.
            if (currentSeries && !currentSeries.pixel_spacing && currentPixelSpacing) {
                currentSeries.pixel_spacing = `${currentPixelSpacing.row}\\${currentPixelSpacing.col}`;
                updateImageInfo(currentSeries);
            }

            updateSliders();
            lastLoadedImagePayload = data;
            lastLoadedImageId = imageId;
            renderDicomImage(data);
            _scheduleMPRRefresh();
        }

        function scheduleLoadCurrentImage(index = currentImageIndex) {
            if (!imageData || !imageData.length) return;
            const clamped = Math.max(0, Math.min(imageData.length - 1, Number(index) || 0));
            _scheduledLoadIndex = clamped;

            // Update UI immediately (feels responsive) even if the load is coalesced.
            currentImageIndex = clamped;
            const sliceSlider = document.getElementById('sliceSlider');
            if (sliceSlider) sliceSlider.value = clamped;
            const sliceValue = document.getElementById('sliceValue');
            if (sliceValue) sliceValue.textContent = clamped + 1;
            const currentSliceEl = document.getElementById('currentSlice');
            if (currentSliceEl) currentSliceEl.textContent = clamped + 1;

            if (_scheduledLoadRaf) return;
            _scheduledLoadRaf = requestAnimationFrame(async () => {
                _scheduledLoadRaf = null;
                const idx = _scheduledLoadIndex;
                _scheduledLoadIndex = null;
                await loadCurrentImage(idx);
            });
        }

        async function loadCurrentImage(index = currentImageIndex) {
            if (!imageData || !imageData.length) return;
            const idx = Math.max(0, Math.min(imageData.length - 1, Number(index) || 0));
            const entry = imageData[idx];
            if (!entry) return;

            const imageId = entry.id;
            const cacheHit = _cacheGetPayload(imageId);
            if (cacheHit && cacheHit.pixel_data) {
                _resetServerRendered();
                _applyLoadedImagePayload(cacheHit, imageId);
                _schedulePrefetchAround(idx);
                return;
            }

            // Abort any in-flight image load (latest-slice-wins during scrolling).
            try { _imageLoadAbortController?.abort(); } catch (e) {}
            _imageLoadAbortController = new AbortController();
            const seq = ++_imageLoadSeq;

            // Avoid flickery loaders during fast wheel scrolls: show only if it takes noticeable time.
            let loaderTimer = setTimeout(() => showLoading(true), 150);
            try {
                let data = null;
                let lastErr = null;
                for (let attempt = 0; attempt < 3; attempt++) {
                    try {
                        // Prefer raw float32 bytes (lower overhead), fall back to JSON packed if unsupported.
                        data = await _fetchImagePayloadBinary(imageId, _imageLoadAbortController.signal);
                        if (!data) {
                            data = await _fetchImagePayloadJsonPacked(imageId, _imageLoadAbortController.signal);
                        }
                        lastErr = null;
                        break;
                    } catch (e) {
                        // Ignore aborts (expected during scrolling).
                        if (e && (e.name === 'AbortError' || String(e).includes('AbortError'))) throw e;
                        lastErr = e;
                        if (attempt < 2) {
                            await _delay(160 * Math.pow(2, attempt));
                            continue;
                        }
                    }
                }
                if (!data) throw (lastErr || new Error('Failed to load image payload'));
                if (seq !== _imageLoadSeq) return; // stale

                // Keep W/L in sync even if pixels are missing (helps server-render fallback pick good defaults).
                try {
                    if (data && Number.isFinite(Number(data.window_width))) windowWidth = Number(data.window_width);
                    if (data && Number.isFinite(Number(data.window_center))) windowLevel = Number(data.window_center);
                    updateSliders();
                } catch (e) {}

                if (!data || !data.pixel_data || !data.columns || !data.rows) {
                    // Don't silently render nothing  try server-rendered PNG fallback (still supports pan/zoom/rotate).
                    const warn = (data && data.warnings) || {};
                    if (warn && warn.pixel_decode_error) {
                        showToast(`Pixel decode unavailable: ${warn.pixel_decode_error}`, 'warning', 4500);
                    }
                    await _loadServerRenderedFrame(imageId, { quiet: true });
                    return;
                }

                _resetServerRendered();
                _cacheSetPayload(imageId, data);
                _applyLoadedImagePayload(data, imageId);
                _schedulePrefetchAround(idx);
            } catch (error) {
                // Ignore aborts (expected during scrolling).
                if (error && (error.name === 'AbortError' || String(error).includes('AbortError'))) return;
                console.error('Error loading image:', error);
                showToast('Failed to load image', 'error');
            } finally {
                clearTimeout(loaderTimer);
                showLoading(false);
            }
        }

        function _schedulePrefetchAround(centerIdx) {
            if (_prefetchTimer) clearTimeout(_prefetchTimer);
            _prefetchTimer = setTimeout(() => {
                _prefetchTimer = null;
                // If a new load is already scheduled, don't compete with it.
                if (_scheduledLoadRaf) return;
                const offsets = [1, -1, 2, -2];
                offsets.forEach((d) => {
                    const idx = centerIdx + d;
                    if (idx < 0 || idx >= imageData.length) return;
                    const id = imageData[idx]?.id;
                    if (!id) return;
                    if (_imagePayloadCache.has(String(id))) return;
                    // Fire-and-forget prefetch; browser cache + our LRU cache will make the next scroll instant.
                    _fetchImagePayloadBinary(id, undefined)
                        .then((d) => d ? d : _fetchImagePayloadJsonPacked(id, undefined))
                        .then((d) => { if (d) _cacheSetPayload(id, d); })
                        .catch(() => {});
                });
            }, 140);
        }

        function renderDicomImage(imageData) {
            if (!imageData || !imageData.pixel_data || !imageData.columns || !imageData.rows) return;

            // Defensive: ensure the main canvas has a real size before drawing.
            // If the container was hidden during a layout pass, the canvas can get stuck at 0x0.
            if (!canvas || canvas.width <= 2 || canvas.height <= 2) {
                try { resizeCanvas(); } catch (e) {}
                if (!canvas || canvas.width <= 2 || canvas.height <= 2) return;
            }

            const imgW = Number(imageData.columns) || 0;
            const imgH = Number(imageData.rows) || 0;
            if (!imgW || !imgH) return;

            // Critical safety check:
            // If the pixel buffer doesn't match rows*cols, ImageData construction can throw and the
            // viewer will appear "loaded" but show a blank canvas. In that case, fall back to the
            // server-rendered PNG endpoint so the user still sees an image.
            try {
                const expected = imgW * imgH;
                const actual = (imageData.pixel_data && imageData.pixel_data.length) ? Number(imageData.pixel_data.length) : 0;
                if (actual !== expected) {
                    const id = imageData.id != null ? String(imageData.id) : String(lastLoadedImageId || '');
                    console.warn('Pixel buffer size mismatch; falling back to server render', { id, imgW, imgH, expected, actual });
                    if (id) _loadServerRenderedFrame(id, { quiet: true }).catch(() => {});
                    return;
                }
            } catch (e) {
                const id = imageData.id != null ? String(imageData.id) : String(lastLoadedImageId || '');
                console.warn('Pixel buffer validation failed; falling back to server render', e);
                if (id) _loadServerRenderedFrame(id, { quiet: true }).catch(() => {});
                return;
            }
            const photometric = (imageData.photometric_interpretation || '').toString().toUpperCase();
            const mono1 = photometric === 'MONOCHROME1';

            // Determine final inversion: MONOCHROME1 is "inverted" by definition.
            const shouldInvert = (!!inverted) !== (!!mono1);

            // Fit-to-viewport base scale (avoid default "too big" / clipped display).
            const rot = ((rotation % 360) + 360) % 360;
            const rotated = (rot === 90 || rot === 270);
            const fitW = rotated ? imgH : imgW;
            const fitH = rotated ? imgW : imgH;
            // Do not upscale above 1.0 by default; downscale if needed to fit.
            const baseScale = Math.min(1, Math.min(canvas.width / fitW, canvas.height / fitH));
            _lastRenderMeta = { imgW, imgH, baseScale, rotDeg: rotation };

            // Build / reuse offscreen grayscale frame for current ww/wl/invert state.
            const imgId = imageData.id != null ? String(imageData.id) : String(lastLoadedImageId || '');
            const cacheKey = `${imgId}|ww:${Math.round(windowWidth)}|wl:${Math.round(windowLevel)}|inv:${shouldInvert ? 1 : 0}`;

            if (!_frameCanvas) {
                _frameCanvas = document.createElement('canvas');
                _frameCtx = _frameCanvas.getContext('2d', { willReadFrequently: false });
            }
            if (_frameCanvas.width !== imgW || _frameCanvas.height !== imgH) {
                _frameCanvas.width = imgW;
                _frameCanvas.height = imgH;
                _frameCacheKey = null;
            }

            if (_frameCacheKey !== cacheKey) {
                try {
                    const pixels = new Uint8ClampedArray(imageData.pixel_data.length * 4);
                    for (let i = 0; i < imageData.pixel_data.length; i++) {
                        let value = imageData.pixel_data[i];
                        value = applyWindowing(value, windowWidth, windowLevel);
                        if (shouldInvert) value = 255 - value;
                        const j = i * 4;
                        pixels[j] = value;
                        pixels[j + 1] = value;
                        pixels[j + 2] = value;
                        pixels[j + 3] = 255;
                    }
                    const imgData = new ImageData(pixels, imgW, imgH);
                    _frameCtx.putImageData(imgData, 0, 0);
                    _frameCacheKey = cacheKey;
                } catch (e) {
                    const id = imageData.id != null ? String(imageData.id) : String(lastLoadedImageId || '');
                    console.error('Canvas render failed; falling back to server render', e);
                    if (id) _loadServerRenderedFrame(id, { quiet: true }).catch(() => {});
                    return;
                }
            }

            // Clear and draw with transform-aware pipeline (drawImage respects transforms).
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();

            // View transform: center, then pan in screen pixels, then rotate, flip, and scale.
            ctx.translate(canvas.width / 2 + panX, canvas.height / 2 + panY);
            if (rotation) ctx.rotate((rotation * Math.PI) / 180);
            const sx = (flipH ? -1 : 1) * (baseScale * zoom);
            const sy = (flipV ? -1 : 1) * (baseScale * zoom);
            ctx.scale(sx, sy);

            // Draw centered
            // Nearest-neighbor is crisp when zooming in; enable smoothing only when downscaling to avoid aliasing.
            const effScale = Math.max(Math.abs(sx), Math.abs(sy));
            ctx.imageSmoothingEnabled = effScale < 1;
            try { ctx.imageSmoothingQuality = 'high'; } catch (e) {}
            ctx.drawImage(_frameCanvas, -imgW / 2, -imgH / 2);
            ctx.restore();

            // Overlays (measurements/annotations/crosshair) are drawn in screen space, but points are stored in image pixels.
            drawMeasurements();
            drawAnnotations();
            if (crosshair) drawCrosshair();
            drawCurrentMeasurement();

            updateOverlayLabels();
        }

        function renderServerRenderedImage() {
            if (!_serverRendered || !_serverRendered.enabled) return;
            if (!canvas || !ctx) return;
            const img = _serverRendered.image;
            if (!img) return;

            // Defensive: ensure the main canvas has a real size before drawing.
            if (!canvas || canvas.width <= 2 || canvas.height <= 2) {
                try { resizeCanvas(); } catch (e) {}
                if (!canvas || canvas.width <= 2 || canvas.height <= 2) return;
            }

            const imgW = img.naturalWidth || img.width || 0;
            const imgH = img.naturalHeight || img.height || 0;
            if (!imgW || !imgH) return;

            // Fit-to-viewport base scale (avoid default "too big" / clipped display).
            const rot = ((rotation % 360) + 360) % 360;
            const rotated = (rot === 90 || rot === 270);
            const fitW = rotated ? imgH : imgW;
            const fitH = rotated ? imgW : imgH;
            const baseScale = Math.min(1, Math.min(canvas.width / fitW, canvas.height / fitH));
            _lastRenderMeta = { imgW, imgH, baseScale, rotDeg: rotation };

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2 + panX, canvas.height / 2 + panY);
            if (rotation) ctx.rotate((rotation * Math.PI) / 180);
            const sx = (flipH ? -1 : 1) * (baseScale * zoom);
            const sy = (flipV ? -1 : 1) * (baseScale * zoom);
            ctx.scale(sx, sy);
            const effScale = Math.max(Math.abs(sx), Math.abs(sy));
            ctx.imageSmoothingEnabled = effScale < 1;
            try { ctx.imageSmoothingQuality = 'high'; } catch (e) {}
            ctx.drawImage(img, -imgW / 2, -imgH / 2);
            ctx.restore();

            drawMeasurements();
            drawAnnotations();
            if (crosshair) drawCrosshair();
            drawCurrentMeasurement();
            updateOverlayLabels();
        }

        function applyWindowing(pixelValue, ww, wl) {
            const w = Math.max(1, Number(ww));
            const c = Number(wl);
            const minVal = c - w / 2;
            const v = (Number(pixelValue) - minVal) * (255 / w);
            if (v <= 0) return 0;
            if (v >= 255) return 255;
            return (v + 0.5) | 0;
        }

        // Event Handlers
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let currentMeasurement = null;

        function handleMouseDown(event) {
            const pxy = _canvasClientToCanvasPx(canvas, event.clientX, event.clientY);
            lastMouseX = pxy.x;
            lastMouseY = pxy.y;
            
            // Handle right-click for context menu
            if (event.button === 2) {
                event.preventDefault();
                
                // Check if right-click is on a measurement
                const clickedMeasurement = findMeasurementAtPoint(lastMouseX, lastMouseY);
                if (clickedMeasurement !== -1) {
                    // Show context menu at cursor position
                    showContextMenu(event.clientX, event.clientY, clickedMeasurement);
                    return;
                }
                
                // Hide context menu if clicking elsewhere
                hideContextMenu();
                return;
            }
            
            // Handle left-click (button 0)
            if (event.button === 0) {
                // Crosshair rotate: drag the handle to rotate to any degree (single-view).
                if (crosshair && viewMode === 'single' && _hitTestCrosshairRotateHandle(lastMouseX, lastMouseY)) {
                    const c = _crosshairCenterCanvasPoint();
                    _crosshairRotateDrag.active = true;
                    _crosshairRotateDrag.startAngle = Math.atan2(lastMouseY - c.y, lastMouseX - c.x);
                    _crosshairRotateDrag.baseDeg = Number(crosshairRotation) || 0;
                    _crosshairRotateHover = true;
                    isDragging = true;
                    try { canvas.style.cursor = 'grabbing'; } catch (_) {}
                    redrawCurrentImage();
                    return;
                }

                // Alt+click to reposition crosshair when enabled (store in image pixels)
                if (crosshair && event.altKey) {
                    const p = canvasPointToImagePx(lastMouseX, lastMouseY);
                    if (p) {
                        crosshairImagePx = { x: p.x, y: p.y };
                    } else {
                        crosshairImagePx = null;
                    }
                    redrawCurrentImage();
                    return;
                }

                isDragging = true;
                hideContextMenu(); // Hide any open context menu
                
                if (activeTool === 'roi') {
                    const p = canvasPointToImagePx(lastMouseX, lastMouseY);
                    if (!p) return;
                    roiDraft = { mode: 'single', start: { x: p.x, y: p.y }, end: { x: p.x, y: p.y } };
                    redrawCurrentImage();
                } else if (activeTool === 'measure') {
                    startMeasurement(lastMouseX, lastMouseY);
                } else if (activeTool === 'angle') {
                    startAngleMeasurement(lastMouseX, lastMouseY);
                } else if (activeTool === 'area') {
                    startAreaMeasurement(lastMouseX, lastMouseY);
                } else if (activeTool === 'annotate') {
                    addAnnotation(lastMouseX, lastMouseY);
                }
            }
        }

        function findMeasurementAtPoint(x, y) {
            for (let i = measurements.length - 1; i >= 0; i--) {
                const measurement = measurements[i];
                if (measurement.bounds && 
                    x >= measurement.bounds.x1 && x <= measurement.bounds.x2 &&
                    y >= measurement.bounds.y1 && y <= measurement.bounds.y2) {
                    return i;
                }
            }
            return -1;
        }

        function handleMouseMove(event) {
            const pxy = _canvasClientToCanvasPx(canvas, event.clientX, event.clientY);
            const mouseX = pxy.x;
            const mouseY = pxy.y;
            
            // Update Hounsfield value display
            updateHounsfieldValue(mouseX, mouseY);

            // Magnifier works without dragging
            updateMagnifier(mouseX, mouseY);

            // Crosshair rotate hover feedback (single-view).
            // Keep this lightweight: just a hit-test against the small handle.
            if (crosshair && viewMode === 'single') {
                const hover = _hitTestCrosshairRotateHandle(mouseX, mouseY);
                if (hover !== _crosshairRotateHover) {
                    _crosshairRotateHover = hover;
                    try { canvas.style.cursor = _crosshairRotateDrag.active ? 'grabbing' : (hover ? 'grab' : 'crosshair'); } catch (_) {}
                    // Only redraw when the highlight state changes.
                    try { redrawCurrentImage(); } catch (_) {}
                } else {
                    try { canvas.style.cursor = _crosshairRotateDrag.active ? 'grabbing' : (hover ? 'grab' : 'crosshair'); } catch (_) {}
                }
            }

            // Crosshair rotate drag (single-view): consumes the drag so we don't window/zoom/pan at the same time.
            if (_crosshairRotateDrag && _crosshairRotateDrag.active) {
                const c = _crosshairCenterCanvasPoint();
                const a = Math.atan2(mouseY - c.y, mouseX - c.x);
                const deltaDeg = (a - _crosshairRotateDrag.startAngle) * (180 / Math.PI);
                crosshairRotation = _normalizeDeg((_crosshairRotateDrag.baseDeg || 0) + deltaDeg);
                redrawCurrentImage();
                lastMouseX = mouseX;
                lastMouseY = mouseY;
                return;
            }
            
            if (!isDragging) return;
            
            const deltaX = mouseX - lastMouseX;
            const deltaY = mouseY - lastMouseY;
            
            switch(activeTool) {
                case 'roi':
                    if (roiDraft && roiDraft.mode === 'single') {
                        const p = canvasPointToImagePx(mouseX, mouseY);
                        if (p) {
                            roiDraft.end = { x: p.x, y: p.y };
                            redrawCurrentImage();
                        }
                    }
                    break;
                case 'windowing':
                    // Drag sensitivity scales with WW so it feels consistent across CT/MR/X-ray ranges.
                    const ww = Math.max(1, Number(windowWidth));
                    const wwStep = Math.max(0.5, ww / 512);
                    const wlStep = Math.max(0.5, ww / 512);
                    windowWidth = Math.round(Number(windowWidth) + deltaX * wwStep);
                    windowLevel = Math.round(Number(windowLevel) + deltaY * wlStep);

                    if (currentImageStats) {
                        windowWidth = _clamp(windowWidth, 1, currentImageStats.wwMax);
                        windowLevel = _clamp(windowLevel, currentImageStats.wlMin, currentImageStats.wlMax);
                    } else {
                        windowWidth = Math.max(1, windowWidth);
                    }
                    updateSliders();
                    redrawCurrentImage();
                    _scheduleMPRRefresh();
                    break;
                case 'zoom':
                    const zoomDelta = 1 + (deltaY * 0.01);
                    zoom = Math.max(0.1, Math.min(5.0, zoom * zoomDelta));
                    updateZoomSlider();
                    redrawCurrentImage();
                    break;
                case 'pan':
                    // Pan in screen pixels (independent of zoom/baseScale)
                    panX += deltaX;
                    panY += deltaY;
                    redrawCurrentImage();
                    break;
                case 'measure':
                case 'angle':
                case 'area':
                    if (currentMeasurement) {
                        updateMeasurement(mouseX, mouseY);
                    }
                    break;
            }
            
            lastMouseX = mouseX;
            lastMouseY = mouseY;
        }

        function updateMagnifier(mouseX, mouseY) {
            if (!magnifierCanvas || !magnifierCtx) return;

            const shouldShow = activeTool === 'magnify';
            magnifierCanvas.style.display = shouldShow ? 'block' : 'none';
            if (!shouldShow) return;

            // Position near cursor, clamp inside host
            const host = canvas.parentElement;
            const pad = 12;
            const x = Math.max(pad, Math.min(host.clientWidth - magnifierSize - pad, mouseX + 16));
            const y = Math.max(pad, Math.min(host.clientHeight - magnifierSize - pad, mouseY + 16));
            magnifierCanvas.style.left = `${x}px`;
            magnifierCanvas.style.top = `${y}px`;

            // Draw zoomed region from the already-rendered main canvas
            const srcSize = magnifierSize / magnifierZoomFactor;
            const sx = Math.max(0, Math.min(canvas.width - srcSize, mouseX - srcSize / 2));
            const sy = Math.max(0, Math.min(canvas.height - srcSize, mouseY - srcSize / 2));

            magnifierCtx.clearRect(0, 0, magnifierSize, magnifierSize);

            // Circular clip
            magnifierCtx.save();
            magnifierCtx.beginPath();
            magnifierCtx.arc(magnifierSize / 2, magnifierSize / 2, magnifierSize / 2 - 2, 0, 2 * Math.PI);
            magnifierCtx.clip();
            magnifierCtx.imageSmoothingEnabled = false;
            magnifierCtx.drawImage(canvas, sx, sy, srcSize, srcSize, 0, 0, magnifierSize, magnifierSize);

            // Crosshair inside magnifier
            magnifierCtx.strokeStyle = 'rgba(255,255,0,0.8)';
            magnifierCtx.lineWidth = 1;
            magnifierCtx.beginPath();
            magnifierCtx.moveTo(magnifierSize / 2, 0);
            magnifierCtx.lineTo(magnifierSize / 2, magnifierSize);
            magnifierCtx.moveTo(0, magnifierSize / 2);
            magnifierCtx.lineTo(magnifierSize, magnifierSize / 2);
            magnifierCtx.stroke();
            magnifierCtx.restore();
        }

        function _computeEllipseStatsFromImagePayload(payload, cx, cy, rx, ry) {
            if (!payload || !payload.pixel_data || !payload.columns || !payload.rows) return null;
            const w = payload.columns;
            const h = payload.rows;
            const data = payload.pixel_data;
            const icx = Math.round(cx), icy = Math.round(cy);
            const irx = Math.max(1, Math.round(rx)), iry = Math.max(1, Math.round(ry));
            const x0 = Math.max(0, icx - irx), x1 = Math.min(w - 1, icx + irx);
            const y0 = Math.max(0, icy - iry), y1 = Math.min(h - 1, icy + iry);
            const rx2 = irx * irx;
            const ry2 = iry * iry;

            let n = 0;
            let mean = 0;
            let m2 = 0;
            let min = Infinity;
            let max = -Infinity;

            for (let yy = y0; yy <= y1; yy++) {
                const dy = yy - icy;
                const dy2 = dy * dy;
                for (let xx = x0; xx <= x1; xx++) {
                    const dx = xx - icx;
                    if ((dx * dx) / rx2 + dy2 / ry2 > 1) continue;
                    const v = data[yy * w + xx];
                    if (!isFinite(v)) continue;
                    n++;
                    const delta = v - mean;
                    mean += delta / n;
                    m2 += delta * (v - mean);
                    if (v < min) min = v;
                    if (v > max) max = v;
                }
            }
            if (!n) return null;
            const variance = n > 1 ? (m2 / (n - 1)) : 0;
            return { mean, std: Math.sqrt(Math.max(0, variance)), min, max, n };
        }

        async function handleMouseUp(event) {
            isDragging = false;

            // End crosshair rotation drag (single-view)
            if (_crosshairRotateDrag && _crosshairRotateDrag.active) {
                _crosshairRotateDrag.active = false;
                try { canvas.style.cursor = _crosshairRotateHover ? 'grab' : 'crosshair'; } catch (_) {}
                try { redrawCurrentImage(); } catch (_) {}
                // Don't fall through into ROI/measurement finalize logic for this mouseup.
                return;
            }

            if (activeTool === 'roi' && roiDraft && roiDraft.mode === 'single') {
                try {
                    const payload = lastLoadedImagePayload;
                    const start = roiDraft.start;
                    const end = roiDraft.end;
                    const cx = (start.x + end.x) / 2;
                    const cy = (start.y + end.y) / 2;
                    const rx = Math.max(1, Math.abs(end.x - start.x) / 2);
                    const ry = Math.max(1, Math.abs(end.y - start.y) / 2);
                    let stats = _computeEllipseStatsFromImagePayload(payload, cx, cy, rx, ry);
                    // Fallback: compute ROI server-side if pixel payload isn't available (e.g. compressed DICOM decode).
                    if (!stats) {
                        const imageId = imageData[currentImageIndex]?.id;
                        if (imageId != null) {
                            const url = `/dicom-viewer/api/hu/?mode=series&image_id=${encodeURIComponent(imageId)}&shape=ellipse&cx=${encodeURIComponent(Math.round(cx))}&cy=${encodeURIComponent(Math.round(cy))}&rx=${encodeURIComponent(Math.round(rx))}&ry=${encodeURIComponent(Math.round(ry))}`;
                            const resp = await fetch(url, { credentials: 'same-origin' });
                            const data = await resp.json();
                            if (!resp.ok) throw new Error(data && (data.error || data.message) ? (data.error || data.message) : `HTTP ${resp.status}`);
                            stats = data && data.stats ? data.stats : null;
                        }
                    }
                    if (!stats) throw new Error('Empty ROI');
                    measurements.push({
                        type: 'roi',
                        mode: 'single',
                        image_id: imageData[currentImageIndex]?.id,
                        cx, cy, rx, ry,
                        stats,
                        createdAt: Date.now(),
                    });
                    updateMeasurementsList();
                    showToast(`ROI mean: ${stats.mean.toFixed(1)} HU`, 'success');
                } catch (e) {
                    showToast(`ROI failed: ${e?.message || e}`, 'error');
                } finally {
                    roiDraft = null;
                    // Deactivate ROI tool after completion.
                    activeTool = 'windowing';
                    refreshToolButtonStates(activeTool);
                    redrawCurrentImage();
                }
                return;
            }

            if ((activeTool === 'measure' || activeTool === 'angle' || activeTool === 'area') && currentMeasurement) {
                finalizeMeasurement();
            }
        }

        function handleWheel(event) {
            event.preventDefault();
            
            if (event.ctrlKey) {
                // Zoom
                const zoomDelta = event.deltaY > 0 ? 0.9 : 1.1;
                zoom = Math.max(0.1, Math.min(5.0, zoom * zoomDelta));
                updateZoomSlider();
                redrawCurrentImage();
            } else {
                // Slice navigation
                const direction = event.deltaY > 0 ? 1 : -1;
                changeSlice(currentImageIndex + direction);
            }
        }

        function handleKeyDown(event) {
            switch(event.key) {
                case '[':
                    if (viewMode === 'mpr') {
                        event.preventDefault();
                        prevSeries().catch(() => {});
                    }
                    break;
                case ']':
                    if (viewMode === 'mpr') {
                        event.preventDefault();
                        nextSeries().catch(() => {});
                    }
                    break;
                case 'ArrowUp':
                case 'ArrowLeft':
                    changeSlice(currentImageIndex - 1);
                    break;
                case 'ArrowDown':
                case 'ArrowRight':
                    changeSlice(currentImageIndex + 1);
                    break;
                case 'r':
                    resetAllDefaults();
                    break;
                case 'i':
                    inverted = !inverted;
                    inversionLockedByUser = true;
                    _setSeriesWindowing(currentSeries && currentSeries.id, windowWidth, windowLevel, inverted);
                    redrawCurrentImage();
                    break;
                case 'c':
                    crosshair = !crosshair;
                    redrawCurrentImage();
                    break;
                case ' ':
                    event.preventDefault();
                    toggleCineMode();
                    break;
                case 'Delete':
                case 'Backspace':
                    if (measurements.length > 0) {
                        clearAllMeasurements();
                    }
                    break;
                case 'Escape':
                    hideContextMenu();
                    currentMeasurement = null;
                    roiDraft = null;
                    if (_mprRoiCapture) {
                        try { window.removeEventListener('mousemove', _mprRoiCapture.onMove); } catch (e) {}
                        try { window.removeEventListener('mouseup', _mprRoiCapture.onUp); } catch (e) {}
                        _mprRoiCapture = null;
                    }
                    if (viewMode === 'single') redrawCurrentImage();
                    break;
            }
        }

        // UI Update Functions
        function updateWindowWidth(value) {
            windowWidth = Math.round(Number(value));
            if (currentImageStats) windowWidth = _clamp(windowWidth, 1, currentImageStats.wwMax);
            document.getElementById('wwValue').textContent = windowWidth;
            document.getElementById('windowWidth').textContent = windowWidth;
            windowingLockedByUser = true;
            _setSeriesWindowing(currentSeries && currentSeries.id, windowWidth, windowLevel, inverted);
            redrawCurrentImage();
            _scheduleMPRRefresh();
        }

        function updateWindowLevel(value) {
            windowLevel = Math.round(Number(value));
            if (currentImageStats) windowLevel = _clamp(windowLevel, currentImageStats.wlMin, currentImageStats.wlMax);
            document.getElementById('wlValue').textContent = windowLevel;
            document.getElementById('windowLevel').textContent = windowLevel;
            windowingLockedByUser = true;
            _setSeriesWindowing(currentSeries && currentSeries.id, windowWidth, windowLevel, inverted);
            redrawCurrentImage();
            _scheduleMPRRefresh();
        }

        function updateSlice(value) {
            // Coalesce rapid slider/wheel updates; latest index wins.
            scheduleLoadCurrentImage(parseInt(value));
        }

        function updateZoom(value) {
            zoom = parseFloat(value) / 100;
            document.getElementById('zoomValue').textContent = value + '%';
            document.getElementById('zoomLevel').textContent = value + '%';
            redrawCurrentImage();
        }

        function updateBoneThreshold(value) {
            boneThreshold = parseInt(value);
            document.getElementById('boneThresholdValue').textContent = boneThreshold;
            if (viewMode === 'mpr') {
                generateBoneReconstruction();
            }
        }

        function updateBoneOpacity(value) {
            boneOpacity = parseFloat(value);
            document.getElementById('boneOpacityValue').textContent = boneOpacity;
            if (viewMode === 'mpr') {
                if (bone3D && bone3D.mesh) {
                    updateBoneMaterialOpacity();
                } else {
                    generateBoneReconstruction();
                }
            }
        }

        function updateSliders() {
            document.getElementById('windowWidthSlider').value = windowWidth;
            document.getElementById('windowLevelSlider').value = windowLevel;
            document.getElementById('wwValue').textContent = windowWidth;
            document.getElementById('wlValue').textContent = windowLevel;
            document.getElementById('windowWidth').textContent = windowWidth;
            document.getElementById('windowLevel').textContent = windowLevel;
        }

        function updateZoomSlider() {
            const zoomPercent = Math.round(zoom * 100);
            document.getElementById('zoomSlider').value = zoomPercent;
            document.getElementById('zoomValue').textContent = zoomPercent + '%';
            document.getElementById('zoomLevel').textContent = zoomPercent + '%';
        }

        function applyPreset(preset) {
            if (preset === 'auto') {
                autoWindowCurrentImage();
                return;
            }
            if (windowPresets[preset]) {
                windowWidth = windowPresets[preset].ww;
                windowLevel = windowPresets[preset].wl;
                updateSliders();
                windowingLockedByUser = true;
                _setSeriesWindowing(currentSeries && currentSeries.id, windowWidth, windowLevel, inverted);
                redrawCurrentImage();
                showToast(`Applied ${preset} preset`, 'success');
            }
        }

        async function autoWindowCurrentImage() {
            try {
                if (!imageData || !imageData.length) return;
                const img = imageData[currentImageIndex];
                if (!img || !img.id) return;
                const response = await fetch(`/dicom-viewer/api/auto-window/${img.id}/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({})
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                if (!data || data.success === false) throw new Error(data?.error || 'Auto window failed');
                if (Number.isFinite(Number(data.window_width))) windowWidth = Math.round(Number(data.window_width));
                if (Number.isFinite(Number(data.window_level))) windowLevel = Math.round(Number(data.window_level));
                updateSliders();
                windowingLockedByUser = true;
                _setSeriesWindowing(currentSeries && currentSeries.id, windowWidth, windowLevel, inverted);
                redrawCurrentImage();
                showToast('Auto window applied', 'success');
            } catch (e) {
                console.error(e);
                showToast('Auto window failed', 'error');
            }
        }

        function changeSlice(newIndex) {
            if (newIndex >= 0 && newIndex < imageData.length) {
                scheduleLoadCurrentImage(newIndex);
            }
        }

        function resetView() {
            zoom = 1.0;
            panX = 0;
            panY = 0;
            rotation = 0;
            flipH = false;
            flipV = false;
            crosshairRotation = 0;
            _crosshairRotateDrag = { active: false, startAngle: 0, baseDeg: 0 };
            _crosshairRotateHover = false;
            updateZoomSlider();
            redrawCurrentImage();
            showToast('View reset', 'success');
        }

        function resetAllDefaults() {
            // Stop any continuous modes / in-flight interactions
            try { stopCine(); } catch (e) {}
            cineMode = false;

            // Abort MPR timers/requests to avoid stale updates after reset
            try { _abortMPRRequestsAndTimers(); } catch (e) {}

            // Cancel ROI/measurement drafts
            currentMeasurement = null;
            roiDraft = null;
            if (_mprRoiCapture) {
                try { window.removeEventListener('mousemove', _mprRoiCapture.onMove); } catch (e) {}
                try { window.removeEventListener('mouseup', _mprRoiCapture.onUp); } catch (e) {}
                _mprRoiCapture = null;
            }

            // Clear overlays + lists
            measurements = [];
            annotations = [];
            try { updateMeasurementsList(); } catch (e) {}

            // Reset primary tools/state toggles
            activeTool = 'windowing';
            inverted = false;
            inversionLockedByUser = false;
            windowingLockedByUser = false;
            crosshair = false;
            crosshairImagePx = null;
            crosshairRotation = 0;
            _crosshairRotateDrag = { active: false, startAngle: 0, baseDeg: 0 };
            _crosshairRotateHover = false;

            // Reset basic view transform
            zoom = 1.0;
            panX = 0;
            panY = 0;
            rotation = 0;
            flipH = false;
            flipV = false;

            // Reset window/level to app defaults
            windowWidth = 400;
            windowLevel = 40;
            currentImageStats = null;
            try { updateSliders(); } catch (e) {}
            try { updateZoomSlider(); } catch (e) {}

            // Clear persisted windowing for this series (so defaults can re-derive).
            try { _clearSeriesWindowing(currentSeries && currentSeries.id); } catch (e) {}

            // Reset MPR state to defaults and return to single-view default layout
            mprCrosshairVoxel = null;
            mprCrosshairSync = true;
            if (mprState) {
                mprState.counts = { axial: 0, sagittal: 0, coronal: 0 };
                mprState.index = { axial: 0, sagittal: 0, coronal: 0 };
                mprState.activePlane = 'axial';
                mprState.maximizedPlane = null;
                mprState.renderMeta = { axial: null, sagittal: null, coronal: null };
                mprState.lastImage = { axial: null, sagittal: null, coronal: null };
            }
            try { setMPRMaximizedPlane(null); } catch (e) {}
            try { setActiveMPRPlane('axial'); } catch (e) {}

            // Reset 3D defaults
            boneThreshold = 200;
            boneOpacity = 0.8;
            smoothSurface = true;
            autoRotate = false;
            try { stopBoneAnimationLoop(); } catch (e) {}
            try { reset3DView(); } catch (e) {}
            // Sync UI widgets if present
            try {
                const t = document.getElementById('boneThresholdSlider');
                if (t) t.value = String(boneThreshold);
                const o = document.getElementById('boneOpacitySlider');
                if (o) o.value = String(boneOpacity);
                const tv = document.getElementById('boneThresholdValue');
                if (tv) tv.textContent = String(boneThreshold);
                const ov = document.getElementById('boneOpacityValue');
                if (ov) ov.textContent = String(boneOpacity);
            } catch (e) {}

            // Return to default single view UI (do not change the loaded series/slice)
            const singleView = document.getElementById('singleView');
            const mprView = document.getElementById('mprView');
            const controls3D = document.getElementById('controls3D');
            if (singleView) singleView.style.display = 'block';
            if (mprView) mprView.classList.remove('active');
            if (controls3D) controls3D.style.display = 'none';
            viewMode = 'single';

            // Re-render
            try { redrawCurrentImage(); } catch (e) {}
            refreshToolButtonStates(activeTool);
            showToast('Reset to defaults', 'success');
        }

        function redrawCurrentImage() {
            if (redrawRaf) return;
            redrawRaf = requestAnimationFrame(() => {
                redrawRaf = null;
                const currentId = imageData[currentImageIndex]?.id;
                if (lastLoadedImagePayload && lastLoadedImageId === currentId) {
                    renderDicomImage(lastLoadedImagePayload);
                } else if (_serverRendered && _serverRendered.enabled && String(_serverRendered.imageId) === String(currentId)) {
                    // If WW/WL/invert changed since the last server render, refresh in the background.
                    const desiredKey = _serverRenderKey(currentId, _serverRendered.info);
                    if (_serverRendered.key !== desiredKey) {
                        _scheduleServerRenderedRefresh(currentId);
                    }
                    renderServerRenderedImage();
                } else {
                    loadCurrentImage();
                }
            });
        }

        // Measurement Functions
        function startMeasurement(x, y) {
            const p = canvasPointToImagePx(x, y);
            if (!p) return;
            currentMeasurement = {
                type: 'distance',
                startX: p.x,
                startY: p.y,
                endX: p.x,
                endY: p.y
            };
        }

        function startAngleMeasurement(x, y) {
            const p = canvasPointToImagePx(x, y);
            if (!p) return;
            currentMeasurement = {
                type: 'angle',
                points: [{ x: p.x, y: p.y }]
            };
        }

        function startAreaMeasurement(x, y) {
            const p = canvasPointToImagePx(x, y);
            if (!p) return;
            currentMeasurement = {
                type: 'area',
                points: [{ x: p.x, y: p.y }]
            };
        }

        function updateMeasurement(x, y) {
            if (!currentMeasurement) return;
            const p = canvasPointToImagePx(x, y);
            if (!p) return;
            
            if (currentMeasurement.type === 'distance') {
                currentMeasurement.endX = p.x;
                currentMeasurement.endY = p.y;
            } else if (currentMeasurement.type === 'angle' || currentMeasurement.type === 'area') {
                // Add point or update last point
                if (currentMeasurement.points.length < 3) {
                    currentMeasurement.points.push({ x: p.x, y: p.y });
                } else {
                    currentMeasurement.points[currentMeasurement.points.length - 1] = { x: p.x, y: p.y };
                }
            }
            
            redrawCurrentImage();
        }

        function finalizeMeasurement() {
            if (!currentMeasurement) return;

            const finalized = { ...currentMeasurement };

            // Compute and store value/unit for list + persistence
            if (finalized.type === 'distance') {
                const d = calculateDistance(finalized);
                finalized.value = d.mm != null ? d.mm : d.pixels;
                finalized.unit = d.mm != null ? 'mm' : 'px';
            } else if (finalized.type === 'angle' && finalized.points && finalized.points.length >= 3) {
                const angle = calculateAngle(finalized.points[0], finalized.points[1], finalized.points[2]);
                finalized.value = Math.round(angle.degrees * 10) / 10;
                finalized.unit = 'deg';
            } else if (finalized.type === 'area' && finalized.points && finalized.points.length >= 3) {
                const a = calculateArea(finalized.points);
                finalized.value = a.mm2 != null ? a.mm2 : a.px2;
                finalized.unit = a.mm2 != null ? 'mm2' : 'px2';
            }

            measurements.push(finalized);
            saveMeasurement(finalized);
            updateMeasurementsList();
            currentMeasurement = null;
            redrawCurrentImage();
            showToast('Measurement saved', 'success');
        }

        function drawMeasurements() {
            if (!measurements || measurements.length === 0) return;
            
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#ff0000';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            
            measurements.forEach((measurement, index) => {
                if (measurement.type === 'distance') {
                    const a = imagePxToCanvasPoint({ x: measurement.startX, y: measurement.startY });
                    const b = imagePxToCanvasPoint({ x: measurement.endX, y: measurement.endY });
                    if (!a || !b) return;
                    // Draw measurement line
                    ctx.beginPath();
                    ctx.moveTo(a.x, a.y);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                    
                    // Draw measurement points
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(a.x, a.y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw distance text with background
                    const distance = calculateDistance(measurement);
                    const midX = (a.x + b.x) / 2;
                    const midY = (a.y + b.y) / 2;
                    
                    // Text background
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(midX - 30, midY - 20, 60, 16);
                    
                    // Text
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText(distance.text, midX, midY - 8);
                    
                    // Store measurement bounds for context menu
                    measurement.bounds = {
                        x1: Math.min(a.x, b.x) - 10,
                        y1: Math.min(a.y, b.y) - 10,
                        x2: Math.max(a.x, b.x) + 10,
                        y2: Math.max(a.y, b.y) + 10,
                        index: index
                    };
                } else if (measurement.type === 'angle' && measurement.points && measurement.points.length >= 3) {
                    // Draw angle measurement
                    const pointsImg = measurement.points;
                    const points = pointsImg.map(p => imagePxToCanvasPoint(p)).filter(Boolean);
                    if (points.length < 3) return;
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y);
                    ctx.lineTo(points[2].x, points[2].y);
                    ctx.stroke();
                    
                    // Draw angle arc
                    const angle = calculateAngle(points[0], points[1], points[2]);
                    ctx.beginPath();
                    ctx.arc(points[1].x, points[1].y, 20, 0, angle.radians);
                    ctx.stroke();
                    
                    // Draw angle text
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText(`${angle.degrees.toFixed(1)}`, points[1].x + 25, points[1].y - 10);
                    
                    measurement.bounds = {
                        x1: Math.min(...points.map(p => p.x)) - 10,
                        y1: Math.min(...points.map(p => p.y)) - 10,
                        x2: Math.max(...points.map(p => p.x)) + 10,
                        y2: Math.max(...points.map(p => p.y)) + 10,
                        index: index
                    };
                } else if (measurement.type === 'area' && measurement.points && measurement.points.length >= 3) {
                    // Draw area measurement
                    const pointsImg = measurement.points;
                    const points = pointsImg.map(p => imagePxToCanvasPoint(p)).filter(Boolean);
                    if (points.length < 3) return;
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    
                    // Fill with transparent color
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                    ctx.fill();
                    
                    // Calculate and display area (mm/cm when PixelSpacing available)
                    const area = calculateArea(points);
                    const centerX = points.reduce((sum, p) => sum + p.x, 0) / points.length;
                    const centerY = points.reduce((sum, p) => sum + p.y, 0) / points.length;
                    
                    ctx.fillStyle = '#ffff00';
                    ctx.fillText(area.text, centerX, centerY);
                    
                    measurement.bounds = {
                        x1: Math.min(...points.map(p => p.x)) - 10,
                        y1: Math.min(...points.map(p => p.y)) - 10,
                        x2: Math.max(...points.map(p => p.x)) + 10,
                        y2: Math.max(...points.map(p => p.y)) + 10,
                        index: index
                    };
                } else if (measurement.type === 'roi' && (measurement.mode || 'single') === 'single') {
                    const c0 = imagePxToCanvasPoint({ x: measurement.cx, y: measurement.cy });
                    const cxPt = imagePxToCanvasPoint({ x: measurement.cx + measurement.rx, y: measurement.cy });
                    const cyPt = imagePxToCanvasPoint({ x: measurement.cx, y: measurement.cy + measurement.ry });
                    if (!c0 || !cxPt || !cyPt) return;
                    const rX = Math.hypot(cxPt.x - c0.x, cxPt.y - c0.y);
                    const rY = Math.hypot(cyPt.x - c0.x, cyPt.y - c0.y);
                    const ang = Math.atan2(cxPt.y - c0.y, cxPt.x - c0.x);

                    ctx.save();
                    ctx.strokeStyle = 'rgba(0, 212, 255, 0.95)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(c0.x, c0.y, rX, rY, ang, 0, Math.PI * 2);
                    ctx.stroke();
                    // Label (mean HU)
                    if (measurement.stats && typeof measurement.stats.mean === 'number') {
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(c0.x - 46, c0.y - rY - 24, 92, 16);
                        ctx.fillStyle = '#ffff00';
                        ctx.fillText(`${measurement.stats.mean.toFixed(1)} HU`, c0.x, c0.y - rY - 12);
                    }
                    ctx.restore();

                    measurement.bounds = {
                        x1: c0.x - rX - 10,
                        y1: c0.y - rY - 30,
                        x2: c0.x + rX + 10,
                        y2: c0.y + rY + 10,
                        index: index
                    };
                }
            });
        }

        function drawCurrentMeasurement() {
            // ROI tool draft (ellipse)
            if (roiDraft && roiDraft.mode === 'single') {
                const start = roiDraft.start;
                const end = roiDraft.end;
                const cx = (start.x + end.x) / 2;
                const cy = (start.y + end.y) / 2;
                const rx = Math.max(1, Math.abs(end.x - start.x) / 2);
                const ry = Math.max(1, Math.abs(end.y - start.y) / 2);
                const c0 = imagePxToCanvasPoint({ x: cx, y: cy });
                const cxPt = imagePxToCanvasPoint({ x: cx + rx, y: cy });
                const cyPt = imagePxToCanvasPoint({ x: cx, y: cy + ry });
                if (c0 && cxPt && cyPt) {
                    const rX = Math.hypot(cxPt.x - c0.x, cxPt.y - c0.y);
                    const rY = Math.hypot(cyPt.x - c0.x, cyPt.y - c0.y);
                    const ang = Math.atan2(cxPt.y - c0.y, cxPt.x - c0.x);
                    ctx.save();
                    ctx.strokeStyle = 'rgba(0, 212, 255, 0.95)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([6, 4]);
                    ctx.beginPath();
                    ctx.ellipse(c0.x, c0.y, rX, rY, ang, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            if (!currentMeasurement) return;
            
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            if (currentMeasurement.type === 'distance') {
                const a = imagePxToCanvasPoint({ x: currentMeasurement.startX, y: currentMeasurement.startY });
                const b = imagePxToCanvasPoint({ x: currentMeasurement.endX, y: currentMeasurement.endY });
                if (a && b) {
                    ctx.beginPath();
                    ctx.moveTo(a.x, a.y);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                }
            }
            
            ctx.setLineDash([]);
        }

        function drawAnnotations() {
            // Implementation for drawing annotations
            annotations.forEach(annotation => {
                const pt = imagePxToCanvasPoint({ x: annotation.x, y: annotation.y });
                if (!pt) return;
                ctx.fillStyle = annotation.color || '#ffff00';
                ctx.font = '14px Arial';
                ctx.fillText(annotation.text, pt.x, pt.y);
            });
        }

        // Crosshair is stored in image pixel coordinates (not canvas coordinates)
        let crosshairImagePx = null; // { x, y } in image px

        function _normalizeDeg(d) {
            const n = Number(d) || 0;
            return ((n % 360) + 360) % 360;
        }

        function _crosshairCenterCanvasPoint() {
            const pt = crosshairImagePx ? imagePxToCanvasPoint(crosshairImagePx) : null;
            return {
                x: (pt && pt.x != null) ? pt.x : (canvas.width / 2),
                y: (pt && pt.y != null) ? pt.y : (canvas.height / 2),
            };
        }

        function _crosshairAxesForCanvas() {
            const rot = _normalizeDeg(rotation);
            const rot2 = _normalizeDeg(crosshairRotation);
            const total = _normalizeDeg(rot + rot2);
            const angle = (total * Math.PI) / 180;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const fx = flipH ? -1 : 1;
            const fy = flipV ? -1 : 1;
            // Image X axis (columns)
            const xdx = fx * cos;
            const xdy = fx * sin;
            // Image Y axis (rows)
            const ydx = fy * (-sin);
            const ydy = fy * (cos);
            return { xdx, xdy, ydx, ydy };
        }

        function _crosshairRotateHandleCanvasPoint() {
            const c = _crosshairCenterCanvasPoint();
            const ax = _crosshairAxesForCanvas();
            const handleDist = 26;
            return { x: c.x + handleDist * ax.xdx, y: c.y + handleDist * ax.xdy };
        }

        function _hitTestCrosshairRotateHandle(canvasX, canvasY) {
            if (!crosshair) return false;
            if (viewMode !== 'single') return false;
            const h = _crosshairRotateHandleCanvasPoint();
            const dx = canvasX - h.x;
            const dy = canvasY - h.y;
            return (dx * dx + dy * dy) <= (10 * 10);
        }

        function drawCrosshair() {
            const pt = crosshairImagePx ? imagePxToCanvasPoint(crosshairImagePx) : null;
            const centerX = (pt && pt.x != null) ? pt.x : (canvas.width / 2);
            const centerY = (pt && pt.y != null) ? pt.y : (canvas.height / 2);

            const isRotateActive = !!(_crosshairRotateDrag && _crosshairRotateDrag.active);
            const isRotateHover = !!_crosshairRotateHover;
            const highlight = isRotateActive || isRotateHover;

            ctx.strokeStyle = highlight ? 'rgba(255,255,0,0.95)' : '#00ffff';
            ctx.lineWidth = highlight ? 2 : 1;
            ctx.setLineDash(highlight ? [] : [3, 3]);

            // Draw crosshair aligned to the image axes (rotates with the image).
            const rot = ((Number(rotation) || 0) % 360 + 360) % 360;
            // Additional crosshair rotation for alignment (does not rotate the pixels).
            const rot2 = ((Number(crosshairRotation) || 0) % 360 + 360) % 360;
            const total = ((rot + rot2) % 360 + 360) % 360;
            const angle = (total * Math.PI) / 180;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const len = Math.max(canvas.width, canvas.height) * 1.4;
            const half = len / 2;

            // Image axis directions in canvas space.
            // Must include flips so the crosshair stays aligned to the displayed image orientation.
            const fx = flipH ? -1 : 1;
            const fy = flipV ? -1 : 1;
            // Image X axis (columns)
            const xdx = fx * cos;
            const xdy = fx * sin;
            // Image Y axis (rows)
            const ydx = fy * (-sin);
            const ydy = fy * (cos);

            ctx.beginPath();
            // X axis line
            ctx.moveTo(centerX + (-half) * xdx, centerY + (-half) * xdy);
            ctx.lineTo(centerX + (half) * xdx, centerY + (half) * xdy);
            // Y axis line
            ctx.moveTo(centerX + (-half) * ydx, centerY + (-half) * ydy);
            ctx.lineTo(centerX + (half) * ydx, centerY + (half) * ydy);
            ctx.stroke();
            
            ctx.setLineDash([]);

            // Rotation handle (drag to rotate crosshair to any degree).
            // Handle sits on the +X axis of the crosshair.
            const handleDist = 26;
            const hx = centerX + handleDist * xdx;
            const hy = centerY + handleDist * xdy;

            // Optional rotate ring highlight
            if (highlight) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255,255,0,0.35)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(centerX, centerY, handleDist, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            ctx.save();
            ctx.fillStyle = highlight ? 'rgba(255,255,0,0.9)' : 'rgba(0, 212, 255, 0.9)';
            ctx.strokeStyle = 'rgba(0,0,0,0.65)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(hx, hy, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();

            // Small center marker + rotation glyph when the view is rotated.
            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,0.65)';
            ctx.strokeStyle = 'rgba(255,255,255,0.9)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 3.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // Show a glyph when either the image or the crosshair is rotated.
            if (rot !== 0 || rot2 !== 0) {
                const r = 9;
                const start = -Math.PI / 3;
                const end = (Math.PI * 4) / 3;
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.lineWidth = 1.4;
                ctx.beginPath();
                ctx.arc(centerX, centerY, r, start, end);
                ctx.stroke();
                // Arrow head
                const ax = centerX + r * Math.cos(end);
                const ay = centerY + r * Math.sin(end);
                const ah = 4.5;
                ctx.fillStyle = 'rgba(255,255,255,0.85)';
                ctx.beginPath();
                ctx.moveTo(ax, ay);
                ctx.lineTo(ax - ah * Math.cos(end - Math.PI / 7), ay - ah * Math.sin(end - Math.PI / 7));
                ctx.lineTo(ax - ah * Math.cos(end + Math.PI / 7), ay - ah * Math.sin(end + Math.PI / 7));
                ctx.closePath();
                ctx.fill();
            }
            ctx.restore();
        }

        function formatLengthFromMm(mm) {
            if (mm == null || !isFinite(mm)) return { text: null };
            if (mm >= 10) {
                const cm = mm / 10;
                const v = Math.round(cm * 100) / 100;
                return { text: `${v} cm` };
            }
            const v = Math.round(mm * 100) / 100;
            return { text: `${v} mm` };
        }

        function calculateDistance(measurement) {
            const deltaX = measurement.endX - measurement.startX;
            const deltaY = measurement.endY - measurement.startY;
            const pixelDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

            const spacing = getPixelSpacing();
            if (spacing) {
                // Non-square pixels: scale per axis
                const dxMm = deltaX * spacing.col;
                const dyMm = deltaY * spacing.row;
                const mm = Math.sqrt(dxMm * dxMm + dyMm * dyMm);
                return {
                    pixels: Math.round(pixelDistance),
                    mm: Math.round(mm * 100) / 100,
                    text: formatLengthFromMm(mm).text
                };
            }

            return {
                pixels: Math.round(pixelDistance),
                mm: null,
                text: `${Math.round(pixelDistance)} px`
            };
        }

        function calculatePolygonAreaPx2(points) {
            if (!points || points.length < 3) return 0;
            let area = 0;
            for (let i = 0; i < points.length; i++) {
                const j = (i + 1) % points.length;
                area += points[i].x * points[j].y;
                area -= points[j].x * points[i].y;
            }
            return Math.abs(area / 2);
        }

        function formatAreaFromMm2(mm2) {
            if (mm2 == null || !isFinite(mm2)) return { text: null };
            if (mm2 >= 100) {
                const cm2 = mm2 / 100;
                const v = Math.round(cm2 * 100) / 100;
                return { text: `${v} cm` };
            }
            const v = Math.round(mm2 * 100) / 100;
            return { text: `${v} mm` };
        }

        function calculateArea(points) {
            const px2 = calculatePolygonAreaPx2(points);
            const spacing = getPixelSpacing();
            if (spacing) {
                const mm2 = px2 * spacing.row * spacing.col;
                return {
                    px2: Math.round(px2 * 100) / 100,
                    mm2: Math.round(mm2 * 100) / 100,
                    text: formatAreaFromMm2(mm2).text
                };
            }
            return {
                px2: Math.round(px2 * 100) / 100,
                mm2: null,
                text: `${Math.round(px2 * 100) / 100} px`
            };
        }

        async function saveMeasurement(measurement) {
            if (!currentSeries) return;
            
            try {
                const typeMap = { distance: 'length', angle: 'angle', area: 'area' };
                const backendType = typeMap[measurement.type] || measurement.type;
                const spacing = getPixelSpacing();

                const response = await fetch('/dicom-viewer/measurements/save/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        image_id: imageData[currentImageIndex].id,
                        measurement_type: backendType,
                        points: JSON.stringify(measurement),
                        value: measurement.type === 'distance'
                            ? (calculateDistance(measurement).mm ?? calculateDistance(measurement).pixels)
                            : (measurement.value ?? null),
                        unit: measurement.type === 'distance'
                            ? (spacing ? 'mm' : 'px')
                            : (measurement.unit || (spacing ? 'mm' : 'px'))
                    })
                });
                
                if (response.ok) {
                    console.log('Measurement saved successfully');
                }
            } catch (error) {
                console.error('Error saving measurement:', error);
            }
        }

        function addAnnotation(x, y) {
            const text = prompt('Enter annotation text:');
            if (text) {
                const p = canvasPointToImagePx(x, y);
                if (!p) return;
                const annotation = {
                    x: p.x,
                    y: p.y,
                    text: text,
                    color: '#ffff00'
                };
                annotations.push(annotation);
                redrawCurrentImage();
                saveAnnotation(annotation);
                showToast('Annotation added', 'success');
            }
        }

        async function saveAnnotation(annotation) {
            if (!currentSeries) return;
            
            try {
                const response = await fetch('/dicom-viewer/annotations/save/', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        image_id: imageData[currentImageIndex].id,
                        position_x: annotation.x,
                        position_y: annotation.y,
                        text: annotation.text,
                        color: annotation.color
                    })
                });
                
                if (response.ok) {
                    console.log('Annotation saved successfully');
                }
            } catch (error) {
                console.error('Error saving annotation:', error);
            }
        }

        function updateMeasurementsList() {
            const container = document.getElementById('measurementsList');
            container.innerHTML = '';
            
            if (measurements.length === 0) {
                container.innerHTML = '<div class="measurement-item">No measurements yet. Use the measure tool to add measurements.</div>';
                return;
            }
            
            measurements.forEach((measurement, index) => {
                const item = document.createElement('div');
                item.className = 'measurement-item';
                
                if (measurement.type === 'distance') {
                    const distance = calculateDistance(measurement);
                    item.innerHTML = `
                        <strong>Distance ${index + 1}</strong><br>
                        Length: ${distance.text}
                    `;
                } else if (measurement.type === 'angle') {
                    item.innerHTML = `
                        <strong>Angle ${index + 1}</strong><br>
                        Angle: ${measurement.value || 'N/A'}
                    `;
                } else if (measurement.type === 'area') {
                    const area = calculateArea(measurement.points || []);
                    item.innerHTML = `
                        <strong>Area ${index + 1}</strong><br>
                        Area: ${area.text || 'N/A'}
                    `;
                } else if (measurement.type === 'roi') {
                    const s = measurement.stats;
                    const mean = s && typeof s.mean === 'number' ? s.mean.toFixed(1) : 'N/A';
                    const std = s && typeof s.std === 'number' ? s.std.toFixed(1) : 'N/A';
                    const min = s && typeof s.min === 'number' ? s.min.toFixed(1) : 'N/A';
                    const max = s && typeof s.max === 'number' ? s.max.toFixed(1) : 'N/A';
                    const n = s && typeof s.n === 'number' ? s.n : 'N/A';
                    const where = measurement.mode === 'mpr'
                        ? `MPR ${measurement.plane || ''} (slice ${Number(measurement.slice ?? 0) + 1})`
                        : 'Single slice';
                    item.innerHTML = `
                        <strong>ROI ${index + 1}</strong><br>
                        ${where}<br>
                        Mean: ${mean} HU &nbsp; SD: ${std}<br>
                        Min/Max: ${min} / ${max} &nbsp; N: ${n}
                    `;
                }
                
                container.appendChild(item);
            });
        }

        function clearAllMeasurements() {
            measurements = [];
            annotations = [];
            currentMeasurement = null;
            mprCurrentMeasurement = null;
            roiDraft = null;
            updateMeasurementsList();
            if (viewMode === 'mpr') {
                redrawAllMPRPlanes();
            } else {
                redrawCurrentImage();
            }
            showToast('All measurements cleared', 'success');
        }

        function deleteMeasurement(index) {
            if (index >= 0 && index < measurements.length) {
                const measurement = measurements[index];
                measurements.splice(index, 1);
                updateMeasurementsList();
                if (viewMode === 'mpr') {
                    redrawAllMPRPlanes();
                } else {
                    redrawCurrentImage();
                }
                showToast(`${measurement.type} measurement deleted`, 'success');
                hideContextMenu();
            }
        }

        function calculateAngle(p1, p2, p3) {
            const a = Math.sqrt(Math.pow(p2.x - p3.x, 2) + Math.pow(p2.y - p3.y, 2));
            const b = Math.sqrt(Math.pow(p1.x - p3.x, 2) + Math.pow(p1.y - p3.y, 2));
            const c = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            
            const radians = Math.acos((a * a + c * c - b * b) / (2 * a * c));
            const degrees = radians * (180 / Math.PI);
            
            return { radians, degrees };
        }

        function calculatePolygonArea(points) {
            return calculatePolygonAreaPx2(points);
        }

        // Context Menu Functions
        function showContextMenu(x, y, measurementIndex) {
            hideContextMenu();
            
            const contextMenu = document.createElement('div');
            contextMenu.id = 'measurementContextMenu';
            contextMenu.style.cssText = `
                position: fixed;
                left: ${x}px;
                top: ${y}px;
                background: var(--card-bg);
                border: 1px solid var(--border-color);
                border-radius: 6px;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                z-index: 10000;
                min-width: 150px;
                padding: 5px 0;
                font-size: 14px;
            `;
            
            const deleteOption = document.createElement('div');
            deleteOption.style.cssText = `
                padding: 8px 16px;
                cursor: pointer;
                color: var(--danger-color);
                transition: background 0.2s;
            `;
            deleteOption.innerHTML = '<i class="fas fa-trash"></i> Delete Measurement';
            deleteOption.addEventListener('mouseenter', () => {
                deleteOption.style.background = 'rgba(255, 68, 68, 0.1)';
            });
            deleteOption.addEventListener('mouseleave', () => {
                deleteOption.style.background = 'transparent';
            });
            deleteOption.addEventListener('click', () => {
                deleteMeasurement(measurementIndex);
            });
            
            const copyOption = document.createElement('div');
            copyOption.style.cssText = `
                padding: 8px 16px;
                cursor: pointer;
                color: var(--text-primary);
                transition: background 0.2s;
            `;
            copyOption.innerHTML = '<i class="fas fa-copy"></i> Copy Value';
            copyOption.addEventListener('mouseenter', () => {
                copyOption.style.background = 'var(--border-color)';
            });
            copyOption.addEventListener('mouseleave', () => {
                copyOption.style.background = 'transparent';
            });
            copyOption.addEventListener('click', () => {
                copyMeasurementValue(measurementIndex);
            });
            
            contextMenu.appendChild(deleteOption);
            contextMenu.appendChild(copyOption);
            document.body.appendChild(contextMenu);
            
            // Close context menu when clicking elsewhere
            setTimeout(() => {
                document.addEventListener('click', hideContextMenu, { once: true });
            }, 100);
        }

        function hideContextMenu() {
            const existingMenu = document.getElementById('measurementContextMenu');
            if (existingMenu) {
                existingMenu.remove();
            }
        }

        function copyMeasurementValue(index) {
            if (index >= 0 && index < measurements.length) {
                const measurement = measurements[index];
                let value = '';
                
                if (measurement.type === 'distance') {
                    const distance = calculateDistance(measurement);
                    value = distance.text;
                } else if (measurement.type === 'angle') {
                    const angle = calculateAngle(measurement.points[0], measurement.points[1], measurement.points[2]);
                    value = `${angle.degrees.toFixed(1)}`;
                } else if (measurement.type === 'area') {
                    const area = calculateArea(measurement.points || []);
                    value = area.text || 'N/A';
                } else if (measurement.type === 'roi') {
                    const s = measurement.stats;
                    value = (s && typeof s.mean === 'number') ? `${s.mean.toFixed(1)} HU` : 'N/A';
                }
                
                navigator.clipboard.writeText(value).then(() => {
                    showToast(`Copied: ${value}`, 'success');
                    hideContextMenu();
                }).catch(() => {
                    showToast('Failed to copy to clipboard', 'error');
                    hideContextMenu();
                });
            }
        }

        function updatePatientInfo(study) {
            document.getElementById('patientInfo').textContent = 
                `Patient: ${study.patient_name} | Study Date: ${study.study_date} | Modality: ${study.modality}`;
        }

        function updateImageInfo(series) {
            document.getElementById('imageDimensions').textContent = 
                series.image_count > 0 ? `${imageData[0].columns}  ${imageData[0].rows}` : '-';
            
            document.getElementById('pixelSpacing').textContent = 
                (() => {
                    const ps = _normalizePixelSpacing(series && series.pixel_spacing) || currentPixelSpacing;
                    return ps ? `${ps.row}  ${ps.col} mm` : '-';
                })();
            
            document.getElementById('seriesDescription').textContent = series.description || '-';
            document.getElementById('institutionName').textContent = currentStudy?.institution_name || '-';
        }

        function updateOverlayLabels() {
            document.getElementById('windowWidth').textContent = windowWidth;
            document.getElementById('windowLevel').textContent = windowLevel;
            document.getElementById('currentSlice').textContent = currentImageIndex + 1;
            document.getElementById('totalSlices').textContent = imageData.length;
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
        }

        function updateHounsfieldValue(mouseX, mouseY) {
            // Single-slice mode: compute from loaded float32 pixel buffer (already rescaled on backend for CT).
            if (viewMode !== 'single') {
                document.getElementById('hounsfield').textContent = '-';
                return;
            }
            const payload = lastLoadedImagePayload;
            if (!payload || !payload.pixel_data || !payload.columns || !payload.rows) {
                document.getElementById('hounsfield').textContent = '-';
                return;
            }
            const p = canvasPointToImagePx(mouseX, mouseY);
            if (!p) {
                document.getElementById('hounsfield').textContent = '-';
                return;
            }
            const ix = Math.floor(p.x);
            const iy = Math.floor(p.y);
            const w = payload.columns;
            const h = payload.rows;
            if (ix < 0 || iy < 0 || ix >= w || iy >= h) {
                document.getElementById('hounsfield').textContent = '-';
                return;
            }
            const v = payload.pixel_data[iy * w + ix];
            if (v == null || !isFinite(v)) {
                document.getElementById('hounsfield').textContent = '-';
                return;
            }
            document.getElementById('hounsfield').textContent = (Math.round(v * 10) / 10).toString();
        }

        // MPR and 3D Functions
        // Backwards-compatible alias (some buttons call generateMPR()).
        async function generateMPR() {
            if (viewMode === 'single') {
                toggleMPRView();
                return;
            }
            return generateMPRViews({ refreshBone: true, quiet: false, preserveSlices: false });
        }

        async function generateMPRViews(opts = {}) {
            if (!currentSeries || currentSeries.id == null) {
                showToast('No series loaded for MPR', 'warning');
                return;
            }
            const { refreshBone = false, quiet = false, preserveSlices = true } = opts || {};
            
            try {
                showLoading(true);
                // MPR canvases might have been hidden at first load (0x0). Resize before rendering.
                try { resizeCanvas(); } catch (e) {}

                const qsBase = `window_width=${encodeURIComponent(windowWidth)}&window_level=${encodeURIComponent(windowLevel)}&inverted=${encodeURIComponent(inverted)}`;
                // Always start with fast for initial responsiveness; we'll upgrade after first paint.
                mprQuality = 'fast';

                // Preserve the per-plane slice index whenever possible (wheel scrolling per plane).
                const canPreserve =
                    preserveSlices &&
                    mprState &&
                    mprState.counts &&
                    mprState.counts.axial > 0 &&
                    mprState.counts.sagittal > 0 &&
                    mprState.counts.coronal > 0;

                if (canPreserve) {
                    const [ax, sa, co] = await Promise.all([
                        fetchMPRPlaneSlice('axial', mprState.index.axial, qsBase),
                        fetchMPRPlaneSlice('sagittal', mprState.index.sagittal, qsBase),
                        fetchMPRPlaneSlice('coronal', mprState.index.coronal, qsBase),
                    ]);

                    mprState.counts.axial = ax.count;
                    mprState.counts.sagittal = sa.count;
                    mprState.counts.coronal = co.count;
                    mprState.index.axial = ax.index;
                    mprState.index.sagittal = sa.index;
                    mprState.index.coronal = co.index;

                    {
                        const settled = await Promise.allSettled([
                            _renderMPRDataUrl('axial', ax.image),
                            _renderMPRDataUrl('sagittal', sa.image),
                            _renderMPRDataUrl('coronal', co.image),
                        ]);
                        const ok = settled.some((r) => r.status === 'fulfilled');
                        if (!ok) throw new Error('All MPR panes failed to render');
                        settled.forEach((r) => { if (r.status === 'rejected') console.warn('MPR pane render failed:', r.reason); });
                    }
                } else {
                    // Fetch metadata only (counts/shape) to avoid large base64 payloads.
                    const response = await fetch(`/dicom-viewer/api/series/${currentSeries.id}/mpr/?${qsBase}&quality=${encodeURIComponent(mprQuality)}&meta_only=1`, { credentials: 'same-origin' });
                    const data = await response.json();
                    if (!response.ok) {
                        const msg = (data && (data.error || data.message)) ? (data.error || data.message) : `HTTP ${response.status}`;
                        throw new Error(msg);
                    }

                    // Initialize counts + mid-slice indices.
                    const counts = data.counts || {};
                    mprState.counts.axial = Number(counts.axial || 0);
                    mprState.counts.sagittal = Number(counts.sagittal || 0);
                    mprState.counts.coronal = Number(counts.coronal || 0);
                    mprState.index.axial = Math.floor((mprState.counts.axial || 1) / 2);
                    mprState.index.sagittal = Math.floor((mprState.counts.sagittal || 1) / 2);
                    mprState.index.coronal = Math.floor((mprState.counts.coronal || 1) / 2);

                    // Fresh MPR generation: reset per-plane pan/zoom and clear drafts (prevents "tools not working")
                    mprViewTransform = {
                        axial: { zoom: 1.0, panX: 0, panY: 0 },
                        sagittal: { zoom: 1.0, panX: 0, panY: 0 },
                        coronal: { zoom: 1.0, panX: 0, panY: 0 },
                    };
                    mprCurrentMeasurement = null;
                    roiDraft = null;

                    // First paint using binary PNG slice endpoints (fast mode).
                    const [ax, sa, co] = await Promise.all([
                        fetchMPRPlaneSlice('axial', mprState.index.axial, qsBase),
                        fetchMPRPlaneSlice('sagittal', mprState.index.sagittal, qsBase),
                        fetchMPRPlaneSlice('coronal', mprState.index.coronal, qsBase),
                    ]);
                    {
                        const settled = await Promise.allSettled([
                            _renderMPRDataUrl('axial', ax.image),
                            _renderMPRDataUrl('sagittal', sa.image),
                            _renderMPRDataUrl('coronal', co.image),
                        ]);
                        const ok = settled.some((r) => r.status === 'fulfilled');
                        if (!ok) throw new Error('All MPR panes failed to render');
                        settled.forEach((r) => { if (r.status === 'rejected') console.warn('MPR pane render failed:', r.reason); });
                    }
                }

                // Initialize/refresh crosshair to the current intersection.
                // This makes the crosshair immediately usable when the user enables it in MPR mode.
                mprCrosshairVoxel = {
                    x: Math.max(0, Math.min((mprState.counts.sagittal || 1) - 1, mprState.index.sagittal || 0)),
                    y: Math.max(0, Math.min((mprState.counts.coronal || 1) - 1, mprState.index.coronal || 0)),
                    z: Math.max(0, Math.min((mprState.counts.axial || 1) - 1, mprState.index.axial || 0)),
                };
                if (crosshair) {
                    // Ensure overlays show immediately after (re)generation.
                    redrawAllMPRPlanes();
                }

                if (refreshBone) {
                    await generateBoneReconstruction();
                }
                if (!quiet) showToast('MPR ready', 'success');

                // Progressive upgrade to high quality (non-blocking).
                // The server is already prewarming in the background; this will swap images as soon as ready.
                _upgradeMPRQualityToHigh(qsBase);
            } catch (error) {
                console.error('Error generating MPR:', error);
                showToast(`Failed to generate MPR: ${error?.message || error}`, 'error');
            } finally {
                showLoading(false);
            }
        }

        async function _upgradeMPRQualityToHigh(qsBase) {
            try {
                // Don't spam; if already high, nothing to do.
                if (mprQuality === 'high') return;
                if (!currentSeries || !mprState) return;

                const target = {
                    axial: mprState.index.axial || 0,
                    sagittal: mprState.index.sagittal || 0,
                    coronal: mprState.index.coronal || 0,
                };

                // Upgrade using the binary PNG endpoint (same pixels, less JSON/base64 overhead).
                // Only swap if the user hasn't moved away from the target slice.
                mprQuality = 'high';
                const mkUrl = (plane, idx) => {
                    return `/dicom-viewer/api/mpr-slice/${encodeURIComponent(currentSeries.id)}/${encodeURIComponent(plane)}/${encodeURIComponent(idx)}/?${qsBase}&quality=high`;
                };
                const axUrl = mkUrl('axial', target.axial);
                const saUrl = mkUrl('sagittal', target.sagittal);
                const coUrl = mkUrl('coronal', target.coronal);

                await Promise.allSettled([
                    ((mprState.index.axial || 0) === target.axial) ? _renderMPRDataUrl('axial', axUrl) : Promise.resolve(),
                    ((mprState.index.sagittal || 0) === target.sagittal) ? _renderMPRDataUrl('sagittal', saUrl) : Promise.resolve(),
                    ((mprState.index.coronal || 0) === target.coronal) ? _renderMPRDataUrl('coronal', coUrl) : Promise.resolve(),
                ]);
            } catch (e) {
                // If upgrade fails, keep fast mode; user still has a working MPR.
                try { mprQuality = 'fast'; } catch (_) {}
            }
        }

        async function _renderMPRDataUrl(viewType, dataUrl) {
            const canvas = mprCanvases[viewType];
            if (!canvas || !dataUrl) return;

            // Ensure the canvas backing store has a real size.
            // When MPR is toggled on, the grid can take a frame to layout; without this,
            // drawing succeeds but nothing is visible (0x0 canvas).
            const _ensureCanvasSize = () => {
                if (canvas.width > 2 && canvas.height > 2) return;
                const host = canvas.parentElement;
                const rect = host ? host.getBoundingClientRect() : null;
                const cw = rect ? Math.floor(rect.width) : 0;
                const ch = rect ? Math.floor(rect.height) : 0;
                if (cw > 2 && ch > 2) {
                    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
                    canvas.width = Math.floor(cw * dpr);
                    canvas.height = Math.floor(ch * dpr);
                    canvas.style.width = cw + 'px';
                    canvas.style.height = ch + 'px';
                }
            };

            _ensureCanvasSize();
            if (canvas.width <= 2 || canvas.height <= 2) {
                // Give layout a frame to apply, then re-measure.
                await new Promise((r) => requestAnimationFrame(r));
                _ensureCanvasSize();
            }
            if (canvas.width <= 2 || canvas.height <= 2) {
                throw new Error(`MPR canvas has zero size (${viewType})`);
            }

            // Ensure canvas is actually paintable/visible.
            canvas.style.display = 'block';
            const ctx = canvas.getContext('2d');
            if (!ctx) {
                throw new Error(`Unable to acquire 2D context for MPR canvas (${viewType})`);
            }
            const img = new Image();
            try { img.decoding = 'async'; } catch (_) {}
            // Backend may return:
            // - a full data URL: "data:image/png;base64,..."
            // - raw base64: "<base64...>"
            // - a URL to a PNG endpoint (used for high-quality MPR slice streaming): "/dicom-viewer/api/mpr-slice/..."
            //
            // IMPORTANT: Do not treat URLs as base64 (that results in an invalid data URL and blank MPR panes).
            const v = (typeof dataUrl === 'string') ? dataUrl.trim() : '';
            const isDataUrl = v.startsWith('data:image');
            const isHttpUrl = v.startsWith('http://') || v.startsWith('https://');
            const isRelativeUrl = v.startsWith('/') || v.startsWith('./') || v.startsWith('../');
            const baseSrc = isDataUrl ? v : (isHttpUrl || isRelativeUrl) ? v : `data:image/png;base64,${v}`;

            // Robust MPR image loading: retry transient failures and add cache-bust only for URL endpoints.
            let lastErr = null;
            for (let attempt = 0; attempt < 3; attempt++) {
                try {
                    let attemptSrc = baseSrc;
                    if (!baseSrc.startsWith('data:image') && attempt > 0) {
                        const sep = attemptSrc.includes('?') ? '&' : '?';
                        attemptSrc = `${attemptSrc}${sep}_cb=${Date.now()}_${attempt}`;
                    }
                    img.src = attemptSrc;
                    await Promise.race([
                        new Promise((resolve, reject) => {
                            img.onload = resolve;
                            img.onerror = () => reject(new Error(`MPR image load failed (${viewType})`));
                        }),
                        new Promise((_, reject) => setTimeout(() => reject(new Error(`MPR image load timeout (${viewType})`)), 20000))
                    ]);
                    lastErr = null;
                    break;
                } catch (e) {
                    lastErr = e;
                    if (attempt < 2) {
                        await _delay(180 * Math.pow(2, attempt));
                        continue;
                    }
                }
            }
            if (lastErr) throw lastErr;

            const w = img.naturalWidth || img.width;
            const h = img.naturalHeight || img.height;
            if (!w || !h) {
                throw new Error(`MPR image decoded with invalid dimensions (${viewType}): ${w}x${h}`);
            }

            // Fit-to-canvas (allow upscaling so MPR fills the pane on large screens).
            const scaleFit = Math.min(canvas.width / w, canvas.height / h);
            const scale = Math.max(0.0001, scaleFit);
            const dw = Math.round(w * scale);
            const dh = Math.round(h * scale);
            const dx = Math.round((canvas.width - dw) / 2);
            const dy = Math.round((canvas.height - dh) / 2);

            // Store mapping meta so MPR HU/ROI can convert canvas coords -> slice pixel coords.
            if (mprState && (viewType === 'axial' || viewType === 'sagittal' || viewType === 'coronal')) {
                // Ensure required sub-objects exist (defensive: avoids "blank canvases" if state was clobbered).
                if (!mprState.baseMeta) mprState.baseMeta = { axial: null, sagittal: null, coronal: null };
                if (!mprState.renderMeta) mprState.renderMeta = { axial: null, sagittal: null, coronal: null };
                if (!mprState.lastImage) mprState.lastImage = { axial: null, sagittal: null, coronal: null };

                // baseMeta is the fit-to-pane rect (prior to user pan/zoom); redrawMPRPlane applies transforms.
                mprState.baseMeta[viewType] = { w, h, dx, dy, dw, dh };
                mprState.lastImage[viewType] = img;
            }

            // Always draw *something* to the canvas, even if overlay code errors.
            // This prevents the "all MPR canvases are blank" failure mode.
            try {
                // Draw base + overlays (ROI + crosshair) in a single pass.
                redrawMPRPlane(viewType);
            } catch (e) {
                try {
                    // Fallback: direct draw without overlays.
                    if (mprState && mprState.renderMeta && (viewType === 'axial' || viewType === 'sagittal' || viewType === 'coronal')) {
                        mprState.renderMeta[viewType] = { w, h, dx, dy, dw, dh };
                    }
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    ctx.globalAlpha = 1;
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.imageSmoothingEnabled = true;
                    try { ctx.imageSmoothingQuality = 'high'; } catch (err) {}
                    ctx.drawImage(img, dx, dy, dw, dh);
                } catch (e2) {
                    throw e; // surface the original error
                }
            }
        }

        function redrawAllMPRPlanes() {
            ['axial', 'sagittal', 'coronal'].forEach((p) => {
                try { redrawMPRPlane(p); } catch (e) {}
            });
        }

        function redrawMPRPlane(plane) {
            if (!(plane === 'axial' || plane === 'sagittal' || plane === 'coronal')) return;
            const c = mprCanvases[plane];
            const base = (mprState.baseMeta && mprState.baseMeta[plane]) ? mprState.baseMeta[plane] : mprState.renderMeta[plane];
            const img = mprState.lastImage[plane];
            if (!c || !base || !img) return;
            const ctx = c.getContext('2d');
            const { w, h } = base;
            const t = (mprViewTransform && mprViewTransform[plane]) ? mprViewTransform[plane] : { zoom: 1.0, panX: 0, panY: 0 };
            const z = Math.max(0.2, Math.min(10.0, Number(t.zoom) || 1.0));
            const centerX = (base.dx + base.dw / 2) + (Number(t.panX) || 0);
            const centerY = (base.dy + base.dh / 2) + (Number(t.panY) || 0);
            const dw = Math.max(2, Math.round(base.dw * z));
            const dh = Math.max(2, Math.round(base.dh * z));
            const dx = Math.round(centerX - dw / 2);
            const dy = Math.round(centerY - dh / 2);

            // Update live renderMeta so HU/ROI mapping uses the post-transform rectangle.
            if (mprState && mprState.renderMeta) {
                mprState.renderMeta[plane] = { w, h, dx, dy, dw, dh };
            }
            ctx.clearRect(0, 0, c.width, c.height);
            // Render MPR with high-quality interpolation for better perceived clarity.
            // (The backend already resamples along Z; this improves browser-side scaling quality.)
            // Smooth for any non-1:1 scaling; keep high quality.
            const s = Math.min(dw / Math.max(1, w), dh / Math.max(1, h));
            ctx.imageSmoothingEnabled = Math.abs(s - 1) > 0.01;
            try { ctx.imageSmoothingQuality = 'high'; } catch (e) {}
            ctx.drawImage(img, dx, dy, dw, dh);

            // ROI draft overlay (if any)
            if (roiDraft && roiDraft.mode === 'mpr' && roiDraft.plane === plane) {
                const sx = dw / w;
                const sy = dh / h;
                const start = roiDraft.start;
                const end = roiDraft.end;
                const cx = (start.x + end.x) / 2;
                const cy = (start.y + end.y) / 2;
                const rx = Math.max(1, Math.abs(end.x - start.x) / 2);
                const ry = Math.max(1, Math.abs(end.y - start.y) / 2);
                const ccx = dx + cx * sx;
                const ccy = dy + cy * sy;
                const crx = rx * sx;
                const cry = ry * sy;
                ctx.save();
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.95)';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.ellipse(ccx, ccy, crx, cry, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // Saved measurements/ROI for this plane+slice (disappear automatically when slice changes)
            try { drawMPRMeasurementsAndRois(plane, ctx); } catch (e) {}

            // Crosshair overlay (linked MPR)
            if (crosshair && mprCrosshairVoxel) {
                drawMPRCrosshair(plane, ctx);
            }
        }

        function _mprSlicePxToCanvasPoint(plane, px, py) {
            const meta = mprState.renderMeta[plane];
            if (!meta) return null;
            const { w, h, dx, dy, dw, dh } = meta;
            if (!w || !h || !dw || !dh) return null;
            return { x: dx + (px * (dw / w)), y: dy + (py * (dh / h)) };
        }

        function drawMPRMeasurementsAndRois(plane, ctx) {
            if (!measurements || measurements.length === 0) return;
            const slice = Number(mprState.index[plane] || 0);
            const meta = mprState.renderMeta[plane];
            if (!meta) return;
            const { w, h, dx, dy, dw, dh } = meta;
            const sx = dw / w;
            const sy = dh / h;

            measurements.forEach((m) => {
                if ((m.mode || 'single') !== 'mpr') return;
                if (m.plane !== plane) return;
                if (Number(m.slice ?? 0) !== slice) return;

                if (m.type === 'roi') {
                    const ccx = dx + (m.cx * sx);
                    const ccy = dy + (m.cy * sy);
                    const crx = Math.max(2, m.rx * sx);
                    const cry = Math.max(2, m.ry * sy);
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255, 170, 0, 0.95)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.ellipse(ccx, ccy, crx, cry, 0, 0, Math.PI * 2);
                    ctx.stroke();
                    if (m.stats && typeof m.stats.mean === 'number') {
                        const txt = `${m.stats.mean.toFixed(1)} HU`;
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(ccx - 46, ccy - cry - 24, 92, 16);
                        ctx.fillStyle = '#ffaa00';
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(txt, ccx, ccy - cry - 12);
                    }
                    ctx.restore();
                    return;
                }

                if (m.type === 'distance') {
                    const a = _mprSlicePxToCanvasPoint(plane, m.startX, m.startY);
                    const b = _mprSlicePxToCanvasPoint(plane, m.endX, m.endY);
                    if (!a || !b) return;
                    ctx.save();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(a.x, a.y);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath(); ctx.arc(a.x, a.y, 3.5, 0, Math.PI * 2); ctx.fill();
                    ctx.beginPath(); ctx.arc(b.x, b.y, 3.5, 0, Math.PI * 2); ctx.fill();
                    const midX = (a.x + b.x) / 2;
                    const midY = (a.y + b.y) / 2;
                    const label = (m.value != null && m.unit) ? `${m.value} ${m.unit}` : 'Distance';
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(midX - 42, midY - 20, 84, 16);
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(label, midX, midY - 8);
                    ctx.restore();
                    return;
                }

                if (m.type === 'angle' && m.points && m.points.length >= 3) {
                    const pts = m.points.map((p) => _mprSlicePxToCanvasPoint(plane, p.x, p.y)).filter(Boolean);
                    if (pts.length < 3) return;
                    ctx.save();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(pts[0].x, pts[0].y);
                    ctx.lineTo(pts[1].x, pts[1].y);
                    ctx.lineTo(pts[2].x, pts[2].y);
                    ctx.stroke();
                    ctx.fillStyle = '#ffff00';
                    const label = (m.value != null) ? `${m.value}` : 'Angle';
                    ctx.font = '12px Arial';
                    ctx.fillText(label, pts[1].x + 28, pts[1].y - 10);
                    ctx.restore();
                    return;
                }

                if (m.type === 'area' && m.points && m.points.length >= 3) {
                    const pts = m.points.map((p) => _mprSlicePxToCanvasPoint(plane, p.x, p.y)).filter(Boolean);
                    if (pts.length < 3) return;
                    ctx.save();
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(pts[0].x, pts[0].y);
                    for (let i = 1; i < pts.length; i++) ctx.lineTo(pts[i].x, pts[i].y);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
                    ctx.fill();
                    const centerX = pts.reduce((s, p) => s + p.x, 0) / pts.length;
                    const centerY = pts.reduce((s, p) => s + p.y, 0) / pts.length;
                    ctx.fillStyle = '#ffff00';
                    ctx.font = '12px Arial';
                    const label = (m.value != null && m.unit) ? `${m.value} ${m.unit}` : 'Area';
                    ctx.fillText(label, centerX, centerY);
                    ctx.restore();
                }
            });

            // Annotations (MPR)
            try {
                (annotations || []).forEach((a) => {
                    if ((a.mode || 'single') !== 'mpr') return;
                    if (a.plane !== plane) return;
                    if (Number(a.slice ?? 0) !== slice) return;
                    const pt = _mprSlicePxToCanvasPoint(plane, a.x, a.y);
                    if (!pt) return;
                    ctx.save();
                    ctx.fillStyle = a.color || '#ffff00';
                    ctx.font = '13px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(a.text || '', pt.x + 4, pt.y - 4);
                    ctx.restore();
                });
            } catch (e) {}

            // Draft measurement (MPR)
            if (mprCurrentMeasurement && mprCurrentMeasurement.mode === 'mpr' && mprCurrentMeasurement.plane === plane && Number(mprCurrentMeasurement.slice ?? 0) === slice) {
                const m = mprCurrentMeasurement;
                ctx.save();
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                if (m.type === 'distance') {
                    const a = _mprSlicePxToCanvasPoint(plane, m.startX, m.startY);
                    const b = _mprSlicePxToCanvasPoint(plane, m.endX, m.endY);
                    if (a && b) {
                        ctx.beginPath();
                        ctx.moveTo(a.x, a.y);
                        ctx.lineTo(b.x, b.y);
                        ctx.stroke();
                    }
                }
                ctx.setLineDash([]);
                ctx.restore();
            }
        }

        function drawMPRCrosshair(plane, ctx) {
            const meta = mprState.renderMeta[plane];
            if (!meta || !mprCrosshairVoxel) return;
            const { w, h, dx, dy, dw, dh } = meta;
            const sx = dw / w;
            const sy = dh / h;

            // Compute crosshair position in slice pixel coordinates for this plane.
            // Backend display convention: sagittal/coronal have vertical flip in Z (np.flipud).
            let px = 0, py = 0;
            if (plane === 'axial') {
                px = mprCrosshairVoxel.x;
                py = mprCrosshairVoxel.y;
            } else if (plane === 'sagittal') {
                px = mprCrosshairVoxel.y;           // columns = y
                py = (h - 1) - mprCrosshairVoxel.z; // rows = z (flipped)
            } else { // coronal
                px = mprCrosshairVoxel.x;           // columns = x
                py = (h - 1) - mprCrosshairVoxel.z; // rows = z (flipped)
            }

            // Clamp to image bounds.
            px = Math.max(0, Math.min(w - 1, px));
            py = Math.max(0, Math.min(h - 1, py));

            const cx = dx + px * sx;
            const cy = dy + py * sy;

            // Color coding (hospital-grade convention-ish):
            // axial line = cyan, sagittal = red, coronal = green.
            const COL_AXIAL = 'rgba(0, 212, 255, 0.95)';
            const COL_SAG = 'rgba(255, 77, 77, 0.95)';
            const COL_COR = 'rgba(77, 255, 77, 0.95)';

            // Pick which line represents which plane in each view.
            let vertCol = COL_SAG;
            let horizCol = COL_COR;
            if (plane === 'sagittal') {
                vertCol = COL_COR;   // x-axis is y (coronal index)
                horizCol = COL_AXIAL; // y-axis is z (axial index)
            } else if (plane === 'coronal') {
                vertCol = COL_SAG;   // x-axis is x (sagittal index)
                horizCol = COL_AXIAL; // y-axis is z (axial index)
            }

            ctx.save();
            ctx.lineWidth = 1.5;
            ctx.setLineDash([]);

            // Horizontal line
            ctx.strokeStyle = horizCol;
            ctx.beginPath();
            ctx.moveTo(dx, cy);
            ctx.lineTo(dx + dw, cy);
            ctx.stroke();

            // Vertical line
            ctx.strokeStyle = vertCol;
            ctx.beginPath();
            ctx.moveTo(cx, dy);
            ctx.lineTo(cx, dy + dh);
            ctx.stroke();

            // Center marker
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.strokeStyle = 'rgba(255,255,255,0.9)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(cx, cy, 3.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }

        async function fetchMPRPlaneSlice(plane, sliceIndex, qsBase) {
            if (!currentSeries) throw new Error('No series loaded');
            if (!(plane === 'axial' || plane === 'sagittal' || plane === 'coronal')) throw new Error('Invalid plane');
            const idx = Math.max(0, Number(sliceIndex) || 0);
            try { _mprPlaneAbort[plane]?.abort(); } catch (e) {}
            const ac = new AbortController();
            _mprPlaneAbort[plane] = ac;

            // Prefer the binary PNG slice endpoint (much smaller than JSON+base64).
            // If counts are known, we can avoid a metadata fetch entirely.
            const knownCount = Number(mprState?.counts?.[plane] || 0);
            const q = (mprQuality === 'high') ? 'high' : 'fast';
            if (knownCount > 0) {
                const clamped = Math.max(0, Math.min(knownCount - 1, Math.round(idx)));
                return {
                    image: `/dicom-viewer/api/mpr-slice/${encodeURIComponent(currentSeries.id)}/${encodeURIComponent(plane)}/${encodeURIComponent(clamped)}/?${qsBase}&quality=${encodeURIComponent(q)}`,
                    index: clamped,
                    count: knownCount,
                };
            }

            // Fallback: ask the JSON endpoint (also returns counts).
            const url = `/dicom-viewer/api/series/${currentSeries.id}/mpr/?plane=${encodeURIComponent(plane)}&slice=${encodeURIComponent(idx)}&${qsBase}&quality=${encodeURIComponent(q)}`;
            const resp = await fetch(url, { credentials: 'same-origin', signal: ac.signal });
            const data = await resp.json();
            if (!resp.ok) {
                const msg = (data && (data.error || data.message)) ? (data.error || data.message) : `HTTP ${resp.status}`;
                throw new Error(msg);
            }
            return {
                image: data.image,
                index: Number.isFinite(Number(data.index)) ? Number(data.index) : idx,
                count: Number.isFinite(Number(data.count)) ? Number(data.count) : (data.counts && data.counts[plane]) || 0,
            };
        }

        function setActiveMPRPlane(plane) {
            if (!(plane === 'axial' || plane === 'sagittal' || plane === 'coronal' || plane === 'bone3d')) return;
            mprState.activePlane = plane;
            document.querySelectorAll('#mprView .mpr-view').forEach((el) => {
                el.classList.toggle('is-active', el.dataset && el.dataset.plane === plane);
            });
        }

        function setMPRMaximizedPlane(planeOrNull) {
            const container = document.getElementById('mprView');
            if (!container) return;
            const plane = planeOrNull && (planeOrNull === 'axial' || planeOrNull === 'sagittal' || planeOrNull === 'coronal' || planeOrNull === 'bone3d') ? planeOrNull : null;
            mprState.maximizedPlane = plane;
            container.classList.toggle('maximized', !!plane);
            document.querySelectorAll('#mprView .mpr-view').forEach((el) => {
                const p = el.dataset && el.dataset.plane;
                el.classList.toggle('maximized', !!plane && p === plane);
            });
        }

        function _mprCanvasToSlicePx(plane, canvasX, canvasY) {
            const meta = mprState.renderMeta[plane];
            if (!meta) return null;
            const { w, h, dx, dy, dw, dh } = meta;
            if (!dw || !dh) return null;
            if (canvasX < dx || canvasY < dy || canvasX > dx + dw || canvasY > dy + dh) return null;
            const x = (canvasX - dx) * (w / dw);
            const y = (canvasY - dy) * (h / dh);
            return { x, y, ix: Math.floor(x), iy: Math.floor(y), w, h };
        }

        function _canvasClientToCanvasPx(c, clientX, clientY) {
            const rect = c.getBoundingClientRect();
            const sx = rect.width ? (c.width / rect.width) : 1;
            const sy = rect.height ? (c.height / rect.height) : 1;
            return {
                x: (clientX - rect.left) * sx,
                y: (clientY - rect.top) * sy,
            };
        }

        function _mprCrosshairCanvasPointForPlane(plane) {
            if (!mprCrosshairVoxel || !mprState || !mprState.renderMeta) return null;
            const meta = mprState.renderMeta[plane];
            if (!meta) return null;
            const { w, h, dx, dy, dw, dh } = meta;
            if (!w || !h || !dw || !dh) return null;
            const sx = dw / w;
            const sy = dh / h;

            // Mirror drawMPRCrosshair() mapping.
            let px = 0, py = 0;
            if (plane === 'axial') {
                px = mprCrosshairVoxel.x;
                py = mprCrosshairVoxel.y;
            } else if (plane === 'sagittal') {
                px = mprCrosshairVoxel.y;
                py = (h - 1) - mprCrosshairVoxel.z;
            } else if (plane === 'coronal') {
                px = mprCrosshairVoxel.x;
                py = (h - 1) - mprCrosshairVoxel.z;
            } else {
                return null;
            }

            px = Math.max(0, Math.min(w - 1, px));
            py = Math.max(0, Math.min(h - 1, py));
            return { x: dx + px * sx, y: dy + py * sy };
        }

        function _scheduleMPRCrosshairDragUpdate(plane, x, y) {
            _mprCrosshairDragPending = { plane, x, y };
            if (_mprCrosshairDragRaf) return;
            _mprCrosshairDragRaf = requestAnimationFrame(() => {
                _mprCrosshairDragRaf = null;
                const p = _mprCrosshairDragPending;
                _mprCrosshairDragPending = null;
                if (!p) return;
                _setMPRCrosshairFromCanvasPoint(p.plane, p.x, p.y, false);
                _scheduleMPRSyncFetch();
            });
        }

        function _clampInt(v, min, max) {
            const n = Math.round(Number(v) || 0);
            return Math.max(min, Math.min(max, n));
        }

        function _setMPRCrosshairFromCanvasPoint(plane, canvasX, canvasY, syncNow = true) {
            const p = _mprCanvasToSlicePx(plane, canvasX, canvasY);
            if (!p) return;
            const counts = mprState.counts || { axial: 0, sagittal: 0, coronal: 0 };
            const maxZ = Math.max(0, (counts.axial || 1) - 1);
            const maxX = Math.max(0, (counts.sagittal || 1) - 1);
            const maxY = Math.max(0, (counts.coronal || 1) - 1);

            let vx = 0, vy = 0, vz = 0;
            if (plane === 'axial') {
                // Axial slice is (y,x)
                vx = _clampInt(p.x, 0, maxX);
                vy = _clampInt(p.y, 0, maxY);
                vz = _clampInt(mprState.index.axial, 0, maxZ);
            } else if (plane === 'sagittal') {
                // Sagittal slice is (z,y) with Z flipped vertically for display.
                vx = _clampInt(mprState.index.sagittal, 0, maxX);
                vy = _clampInt(p.x, 0, maxY);
                vz = _clampInt((p.h - 1) - p.y, 0, maxZ);
            } else if (plane === 'coronal') {
                // Coronal slice is (z,x) with Z flipped vertically for display.
                vx = _clampInt(p.x, 0, maxX);
                vy = _clampInt(mprState.index.coronal, 0, maxY);
                vz = _clampInt((p.h - 1) - p.y, 0, maxZ);
            } else {
                return;
            }

            mprCrosshairVoxel = { x: vx, y: vy, z: vz };
            // Keep per-plane indices consistent with the intersection.
            mprState.index.axial = vz;
            mprState.index.sagittal = vx;
            mprState.index.coronal = vy;

            redrawAllMPRPlanes();
            if (syncNow && mprCrosshairSync) {
                _fetchAndRenderAllMPRPlanes();
            }
        }

        function _fetchAndRenderAllMPRPlanes() {
            if (viewMode !== 'mpr' || !currentSeries) return;
            const qsBase = `window_width=${encodeURIComponent(windowWidth)}&window_level=${encodeURIComponent(windowLevel)}&inverted=${encodeURIComponent(inverted)}`;
            Promise.all([
                fetchMPRPlaneSlice('axial', mprState.index.axial || 0, qsBase),
                fetchMPRPlaneSlice('sagittal', mprState.index.sagittal || 0, qsBase),
                fetchMPRPlaneSlice('coronal', mprState.index.coronal || 0, qsBase),
            ]).then(([ax, sa, co]) => {
                mprState.counts.axial = ax.count || mprState.counts.axial;
                mprState.counts.sagittal = sa.count || mprState.counts.sagittal;
                mprState.counts.coronal = co.count || mprState.counts.coronal;
                mprState.index.axial = ax.index;
                mprState.index.sagittal = sa.index;
                mprState.index.coronal = co.index;
                return Promise.allSettled([
                    _renderMPRDataUrl('axial', ax.image),
                    _renderMPRDataUrl('sagittal', sa.image),
                    _renderMPRDataUrl('coronal', co.image),
                ]);
            }).catch(() => {});
        }

        function _scheduleMPRSyncFetch() {
            if (!mprCrosshairSync || !crosshair) return;
            if (_mprSyncTimer) clearTimeout(_mprSyncTimer);
            _mprSyncTimer = setTimeout(() => {
                _mprSyncTimer = null;
                _fetchAndRenderAllMPRPlanes();
            }, 60);
        }

        function _scheduleMPRHU(plane, canvasX, canvasY) {
            if (viewMode !== 'mpr' || !currentSeries) return;
            const p = _mprCanvasToSlicePx(plane, canvasX, canvasY);
            if (!p) {
                document.getElementById('hounsfield').textContent = '-';
                return;
            }
            if (p.ix < 0 || p.iy < 0 || p.ix >= p.w || p.iy >= p.h) {
                document.getElementById('hounsfield').textContent = '-';
                return;
            }
            if (_mprHUTimer) return;
            _mprHUTimer = setTimeout(async () => {
                _mprHUTimer = null;
                try { _mprHUAbort?.abort(); } catch (e) {}
                const ac = new AbortController();
                _mprHUAbort = ac;
                const slice = mprState.index[plane] || 0;
                const url = `/dicom-viewer/api/hu/?mode=mpr&series_id=${encodeURIComponent(currentSeries.id)}&plane=${encodeURIComponent(plane)}&slice=${encodeURIComponent(slice)}&x=${encodeURIComponent(p.ix)}&y=${encodeURIComponent(p.iy)}&quality=${encodeURIComponent((mprQuality === 'high') ? 'high' : 'fast')}`;
                const resp = await fetch(url, { credentials: 'same-origin', signal: ac.signal });
                const data = await resp.json();
                if (!resp.ok) throw new Error(data && (data.error || data.message) ? (data.error || data.message) : `HTTP ${resp.status}`);
                if (data && typeof data.hu === 'number') {
                    document.getElementById('hounsfield').textContent = (Math.round(data.hu * 10) / 10).toString();
                } else {
                    document.getElementById('hounsfield').textContent = '-';
                }
            }, 120);
        }

        function handleMPRClick(event, plane) {
            if (viewMode !== 'mpr') return;
            if (_mprSuppressNextClick) {
                _mprSuppressNextClick = false;
                return;
            }
            if (activeTool === 'roi' && roiDraft) return; // don't toggle while drawing ROI
            setActiveMPRPlane(plane);
            // In MPR mode, clicking should NOT hide the other planes.
            // Instead: if crosshair is enabled, move the intersection and (optionally) sync.
            if (plane === 'bone3d') return;
            if (crosshair) {
                const c = mprCanvases[plane];
                if (!c) return;
                const p = _canvasClientToCanvasPx(c, event.clientX, event.clientY);
                _setMPRCrosshairFromCanvasPoint(plane, p.x, p.y, true);
            }
        }

        function handleMPRDoubleClick(event, plane) {
            if (viewMode !== 'mpr') return;
            if (activeTool === 'roi' && roiDraft) return;
            setActiveMPRPlane(plane);
            // Double-click toggles maximize (restore 4-up on second double-click).
            if (mprState.maximizedPlane === plane) {
                setMPRMaximizedPlane(null);
            } else {
                setMPRMaximizedPlane(plane);
            }
            // Resize after layout change to keep crisp rendering
            try { resizeCanvas(); } catch (e) {}
            if (plane === 'bone3d') {
                try {
                    if (bone3D && bone3D.renderer && bone3D.scene && bone3D.camera) {
                        renderBoneFrame();
                    } else if (currentSeries) {
                        generateBoneReconstruction().catch(() => {});
                    }
                } catch (e) {}
                return;
            }
            // Re-fetch slices so each canvas gets fresh scaling/meta after resize.
            _fetchAndRenderAllMPRPlanes();
        }

        function handleMPRWheel(event, plane) {
            if (viewMode !== 'mpr') return;
            event.preventDefault();
            if (!currentSeries) return;
            setActiveMPRPlane(plane);
            // Ctrl+wheel zooms the active MPR plane (matches single-view behavior).
            if (event.ctrlKey) {
                const t = mprViewTransform[plane] || (mprViewTransform[plane] = { zoom: 1.0, panX: 0, panY: 0 });
                const d = Math.sign(event.deltaY || 0);
                const z = Number(t.zoom) || 1.0;
                t.zoom = Math.max(0.2, Math.min(10.0, z * (d > 0 ? 0.9 : 1.1)));
                redrawMPRPlane(plane);
                return;
            }
            const delta = Math.sign(event.deltaY || 0);
            const step = delta === 0 ? 0 : (delta > 0 ? 1 : -1);
            const count = mprState.counts[plane] || 0;
            if (!count) return;
            const next = Math.max(0, Math.min(count - 1, (mprState.index[plane] || 0) + step));
            if (next === mprState.index[plane]) return;
            mprState.index[plane] = next;
            // When slice scrolls, any ROI draft should disappear (and saved ROIs/measurements auto-filter per-slice).
            roiDraft = null;
            mprCurrentMeasurement = null;
            const qsBase = `window_width=${encodeURIComponent(windowWidth)}&window_level=${encodeURIComponent(windowLevel)}&inverted=${encodeURIComponent(inverted)}`;
            fetchMPRPlaneSlice(plane, next, qsBase)
                .then((r) => {
                    mprState.index[plane] = r.index;
                    mprState.counts[plane] = r.count || mprState.counts[plane];
                    // Keep crosshair's intersection consistent with linked scrolling.
                    if (crosshair && mprCrosshairVoxel) {
                        if (plane === 'axial') mprCrosshairVoxel.z = mprState.index.axial;
                        if (plane === 'sagittal') mprCrosshairVoxel.x = mprState.index.sagittal;
                        if (plane === 'coronal') mprCrosshairVoxel.y = mprState.index.coronal;
                        // Also keep the other indices tied to the crosshair when syncing.
                        if (mprCrosshairSync) {
                            mprState.index.axial = mprCrosshairVoxel.z;
                            mprState.index.sagittal = mprCrosshairVoxel.x;
                            mprState.index.coronal = mprCrosshairVoxel.y;
                        }
                    }
                    return _renderMPRDataUrl(plane, r.image);
                })
                .then(() => {
                    // Update overlays immediately; schedule linked-plane refresh to avoid spamming requests.
                    if (crosshair) redrawAllMPRPlanes();
                    _scheduleMPRSyncFetch();
                })
                .catch((e) => console.warn('MPR slice fetch failed:', e));
        }

        function handleMPRMouseDown(event, plane) {
            if (viewMode !== 'mpr') return;
            const c = mprCanvases[plane];
            const pxy = c ? _canvasClientToCanvasPx(c, event.clientX, event.clientY) : { x: 0, y: 0 };
            const x = pxy.x;
            const y = pxy.y;
            setActiveMPRPlane(plane);

            // Drag the crosshair intersection in real-time (grab near the center marker).
            if (crosshair && (plane === 'axial' || plane === 'sagittal' || plane === 'coronal') && event.button === 0) {
                const isDrawingTool = (activeTool === 'roi' || activeTool === 'measure' || activeTool === 'angle' || activeTool === 'area' || activeTool === 'annotate');
                if (!isDrawingTool && c) {
                    const target = _mprCrosshairCanvasPointForPlane(plane);
                    if (target) {
                        const rect = c.getBoundingClientRect();
                        const sx = rect.width ? (c.width / rect.width) : 1;
                        const threshold = 12 * sx; // 12 CSS px -> canvas px
                        const dist = Math.hypot(x - target.x, y - target.y);
                        if (dist <= threshold) {
                            event.preventDefault();
                            _mprDragState.down = true;
                            _mprDragState.plane = plane;
                            _mprDragState.tool = 'crosshair';
                            _mprDragState.lastX = x;
                            _mprDragState.lastY = y;
                            _mprDragState.wasDragged = false;
                            _mprSuppressNextClick = true; // suppress click-after-drag
                            _scheduleMPRCrosshairDragUpdate(plane, x, y);
                            return;
                        }
                    }
                }
            }

            if (activeTool === 'roi' && event.button === 0) {
                const p = _mprCanvasToSlicePx(plane, x, y);
                if (!p) return;
                roiDraft = { mode: 'mpr', plane, start: { x: p.x, y: p.y }, end: { x: p.x, y: p.y } };
                redrawMPRPlane(plane);

                // Capture mousemove/mouseup on window so ROI finalizes even if user releases outside pane.
                if (_mprRoiCapture) {
                    try { window.removeEventListener('mousemove', _mprRoiCapture.onMove); } catch (e) {}
                    try { window.removeEventListener('mouseup', _mprRoiCapture.onUp); } catch (e) {}
                    _mprRoiCapture = null;
                }
                const onMove = (ev) => {
                    if (!(roiDraft && roiDraft.mode === 'mpr' && roiDraft.plane === plane)) return;
                    const cc = mprCanvases[plane];
                    if (!cc) return;
                    const pt = _canvasClientToCanvasPx(cc, ev.clientX, ev.clientY);
                    const pp = _mprCanvasToSlicePx(plane, pt.x, pt.y);
                    if (!pp) return;
                    roiDraft.end = { x: pp.x, y: pp.y };
                    redrawMPRPlane(plane);
                };
                const onUp = async () => {
                    try { await handleMPRMouseUp({}, plane); } catch (e) {}
                    try { window.removeEventListener('mousemove', onMove); } catch (e) {}
                    try { window.removeEventListener('mouseup', onUp); } catch (e) {}
                    _mprRoiCapture = null;
                };
                _mprRoiCapture = { plane, onMove, onUp };
                window.addEventListener('mousemove', onMove, { passive: true });
                window.addEventListener('mouseup', onUp, { passive: true });
                return;
            }

            // Other tools in MPR (windowing/zoom/pan/measure/angle/area/annotate)
            if (event.button !== 0) return;
            _mprDragState.down = true;
            _mprDragState.plane = plane;
            _mprDragState.tool = activeTool;
            _mprDragState.lastX = x;
            _mprDragState.lastY = y;
            _mprDragState.wasDragged = false;

            if (activeTool === 'measure' || activeTool === 'angle' || activeTool === 'area') {
                const p = _mprCanvasToSlicePx(plane, x, y);
                if (!p) return;
                const slice = Number(mprState.index[plane] || 0);
                if (activeTool === 'measure') {
                    mprCurrentMeasurement = {
                        type: 'distance',
                        mode: 'mpr',
                        plane,
                        slice,
                        startX: p.x,
                        startY: p.y,
                        endX: p.x,
                        endY: p.y
                    };
                } else if (activeTool === 'angle') {
                    mprCurrentMeasurement = {
                        type: 'angle',
                        mode: 'mpr',
                        plane,
                        slice,
                        points: [{ x: p.x, y: p.y }]
                    };
                } else {
                    mprCurrentMeasurement = {
                        type: 'area',
                        mode: 'mpr',
                        plane,
                        slice,
                        points: [{ x: p.x, y: p.y }]
                    };
                }
                redrawMPRPlane(plane);
                return;
            }

            if (activeTool === 'annotate') {
                const text = prompt('Enter annotation text:');
                if (!text) return;
                const p = _mprCanvasToSlicePx(plane, x, y);
                if (!p) return;
                annotations.push({
                    mode: 'mpr',
                    plane,
                    slice: Number(mprState.index[plane] || 0),
                    x: p.x,
                    y: p.y,
                    text,
                    color: '#ffff00'
                });
                redrawMPRPlane(plane);
                updateMeasurementsList();
                showToast('Annotation added', 'success');
                return;
            }
        }

        function handleMPRMouseMove(event, plane) {
            if (viewMode !== 'mpr') return;
            const c = mprCanvases[plane];
            const pxy = c ? _canvasClientToCanvasPx(c, event.clientX, event.clientY) : { x: 0, y: 0 };
            const x = pxy.x;
            const y = pxy.y;
            _scheduleMPRHU(plane, x, y);
            if (activeTool === 'roi' && roiDraft && roiDraft.mode === 'mpr' && roiDraft.plane === plane) {
                const p = _mprCanvasToSlicePx(plane, x, y);
                if (!p) return;
                roiDraft.end = { x: p.x, y: p.y };
                redrawMPRPlane(plane);
            }

            if (!_mprDragState.down || _mprDragState.plane !== plane) return;
            const dx = x - _mprDragState.lastX;
            const dy = y - _mprDragState.lastY;
            _mprDragState.lastX = x;
            _mprDragState.lastY = y;
            if (Math.abs(dx) + Math.abs(dy) > 1.5) _mprDragState.wasDragged = true;

            if (_mprDragState.tool === 'crosshair') {
                _scheduleMPRCrosshairDragUpdate(plane, x, y);
                return;
            }

            if (activeTool === 'windowing') {
                const ww = Math.max(1, Number(windowWidth));
                const wwStep = Math.max(0.5, ww / 512);
                const wlStep = Math.max(0.5, ww / 512);
                windowWidth = Math.round(Number(windowWidth) + dx * wwStep);
                windowLevel = Math.round(Number(windowLevel) + dy * wlStep);
                if (currentImageStats) {
                    windowWidth = _clamp(windowWidth, 1, currentImageStats.wwMax);
                    windowLevel = _clamp(windowLevel, currentImageStats.wlMin, currentImageStats.wlMax);
                } else {
                    windowWidth = Math.max(1, windowWidth);
                }
                updateSliders();
                _scheduleMPRRefresh();
            } else if (activeTool === 'pan') {
                const t = mprViewTransform[plane] || (mprViewTransform[plane] = { zoom: 1.0, panX: 0, panY: 0 });
                t.panX = (Number(t.panX) || 0) + dx;
                t.panY = (Number(t.panY) || 0) + dy;
                redrawMPRPlane(plane);
            } else if (activeTool === 'zoom') {
                const t = mprViewTransform[plane] || (mprViewTransform[plane] = { zoom: 1.0, panX: 0, panY: 0 });
                const z = Number(t.zoom) || 1.0;
                const factor = 1 + (dy * 0.01);
                t.zoom = Math.max(0.2, Math.min(10.0, z * factor));
                redrawMPRPlane(plane);
            } else if ((activeTool === 'measure' || activeTool === 'angle' || activeTool === 'area') && mprCurrentMeasurement) {
                const p = _mprCanvasToSlicePx(plane, x, y);
                if (!p) return;
                if (mprCurrentMeasurement.type === 'distance') {
                    mprCurrentMeasurement.endX = p.x;
                    mprCurrentMeasurement.endY = p.y;
                } else if (mprCurrentMeasurement.type === 'angle' || mprCurrentMeasurement.type === 'area') {
                    if (mprCurrentMeasurement.points.length < 3) {
                        mprCurrentMeasurement.points.push({ x: p.x, y: p.y });
                    } else {
                        mprCurrentMeasurement.points[mprCurrentMeasurement.points.length - 1] = { x: p.x, y: p.y };
                    }
                }
                redrawMPRPlane(plane);
            }
        }

        async function handleMPRMouseUp(event, plane) {
            if (viewMode !== 'mpr') return;
            // Finalize crosshair drag (force a last sync at the last mouse position)
            if (_mprDragState.down && _mprDragState.plane === plane && _mprDragState.tool === 'crosshair') {
                try {
                    _setMPRCrosshairFromCanvasPoint(plane, _mprDragState.lastX, _mprDragState.lastY, true);
                } catch (e) {}
                _mprDragState.down = false;
                _mprDragState.plane = null;
                _mprDragState.tool = null;
                _mprDragState.wasDragged = false;
                // Suppress the immediately following click event triggered by mouseup.
                _mprSuppressNextClick = true;
                setTimeout(() => { _mprSuppressNextClick = false; }, 0);
                return;
            }
            // Finalize non-ROI drags first
            if (_mprDragState.down && _mprDragState.plane === plane) {
                _mprDragState.down = false;
                _mprDragState.plane = null;
                _mprDragState.tool = null;
                _mprDragState.wasDragged = false;
            }

            // Finalize MPR measurement tools
            if ((activeTool === 'measure' || activeTool === 'angle' || activeTool === 'area') && mprCurrentMeasurement && mprCurrentMeasurement.mode === 'mpr' && mprCurrentMeasurement.plane === plane) {
                const finalized = { ...mprCurrentMeasurement };
                try {
                    if (finalized.type === 'distance') {
                        const d = calculateDistance(finalized);
                        finalized.value = d.mm != null ? d.mm : d.pixels;
                        finalized.unit = d.mm != null ? 'mm' : 'px';
                    } else if (finalized.type === 'angle' && finalized.points && finalized.points.length >= 3) {
                        const a = calculateAngle(finalized.points[0], finalized.points[1], finalized.points[2]);
                        finalized.value = Math.round(a.degrees * 10) / 10;
                        finalized.unit = 'deg';
                    } else if (finalized.type === 'area' && finalized.points && finalized.points.length >= 3) {
                        const a = calculateArea(finalized.points);
                        finalized.value = a.mm2 != null ? a.mm2 : a.px2;
                        finalized.unit = a.mm2 != null ? 'mm2' : 'px2';
                    }
                } catch (e) {}
                measurements.push(finalized);
                mprCurrentMeasurement = null;
                updateMeasurementsList();
                redrawMPRPlane(plane);
                showToast('Measurement saved', 'success');
                return;
            }

            // Finalize ROI (existing logic)
            if (!(activeTool === 'roi' && roiDraft && roiDraft.mode === 'mpr' && roiDraft.plane === plane)) return;
            const start = roiDraft.start;
            const end = roiDraft.end;
            // Ellipse parameters in slice pixel coordinates
            const cx = (start.x + end.x) / 2;
            const cy = (start.y + end.y) / 2;
            const rx = Math.max(1, Math.abs(end.x - start.x) / 2);
            const ry = Math.max(1, Math.abs(end.y - start.y) / 2);
            const slice = mprState.index[plane] || 0;
            try {
                const url = `/dicom-viewer/api/hu/?mode=mpr&series_id=${encodeURIComponent(currentSeries.id)}&plane=${encodeURIComponent(plane)}&slice=${encodeURIComponent(slice)}&shape=ellipse&cx=${encodeURIComponent(Math.round(cx))}&cy=${encodeURIComponent(Math.round(cy))}&rx=${encodeURIComponent(Math.round(rx))}&ry=${encodeURIComponent(Math.round(ry))}&quality=${encodeURIComponent((mprQuality === 'high') ? 'high' : 'fast')}`;
                const resp = await fetch(url, { credentials: 'same-origin' });
                const data = await resp.json();
                if (!resp.ok) throw new Error(data && (data.error || data.message) ? (data.error || data.message) : `HTTP ${resp.status}`);
                if (data && data.stats) {
                    measurements.push({
                        type: 'roi',
                        mode: 'mpr',
                        seriesId: (currentSeries && currentSeries.id != null) ? Number(currentSeries.id) : null,
                        plane,
                        slice,
                        cx, cy, rx, ry,
                        stats: data.stats,
                        createdAt: Date.now(),
                    });
                    updateMeasurementsList();
                    showToast(`ROI mean: ${data.stats.mean.toFixed(1)} HU`, 'success');
                }
            } catch (e) {
                showToast(`ROI failed: ${e?.message || e}`, 'error');
            } finally {
                // Keep the last ROI outline visible by converting to a saved measurement and clearing draft.
                roiDraft = null;
                // Deactivate ROI tool after completion.
                activeTool = 'windowing';
                refreshToolButtonStates(activeTool);
                // Redraw plane without draft overlay
                const qsBase = `window_width=${encodeURIComponent(windowWidth)}&window_level=${encodeURIComponent(windowLevel)}&inverted=${encodeURIComponent(inverted)}`;
                fetchMPRPlaneSlice(plane, mprState.index[plane] || 0, qsBase)
                    .then((r) => _renderMPRDataUrl(plane, r.image))
                    .catch(() => {});
            }
        }

        function drawMPRRoiOverlay(plane) {
            // Backwards compatible wrapper (older codepaths call this).
            redrawMPRPlane(plane);
        }

        async function generateBoneReconstruction() {
            if (!currentSeries) return;
            
            try {
                showLoading(true);

                // Ensure MPR is visible and canvas has real size
                try { resizeCanvas(); } catch (e) {}

                const threshold = Number.isFinite(Number(boneThreshold)) ? Number(boneThreshold) : 300;
                const wantMesh = true;
                const meshQuality = (smoothSurface ? 'high' : 'medium');

                // If the user drew an ROI in MPR, reconstruct only that region (faster + matches expectation).
                // We use the most recent ROI for the current series.
                let roiCropQs = '';
                try {
                    const seriesId = (currentSeries && currentSeries.id != null) ? Number(currentSeries.id) : null;
                    const roi = (measurements || [])
                        .slice()
                        .reverse()
                        .find((m) =>
                            m &&
                            m.type === 'roi' &&
                            (m.mode || 'single') === 'mpr' &&
                            (seriesId == null || Number(m.seriesId) === seriesId)
                        );
                    if (roi && (roi.plane === 'axial' || roi.plane === 'sagittal' || roi.plane === 'coronal')) {
                        const pad = 6;       // pixels (slice coords)
                        const thickness = 10; // slices (extrusion along orthogonal axis)
                        roiCropQs =
                            `&roi_plane=${encodeURIComponent(roi.plane)}` +
                            `&roi_slice=${encodeURIComponent(Number(roi.slice) || 0)}` +
                            `&roi_cx=${encodeURIComponent(Math.round(Number(roi.cx) || 0))}` +
                            `&roi_cy=${encodeURIComponent(Math.round(Number(roi.cy) || 0))}` +
                            `&roi_rx=${encodeURIComponent(Math.round(Number(roi.rx) || 1))}` +
                            `&roi_ry=${encodeURIComponent(Math.round(Number(roi.ry) || 1))}` +
                            `&roi_pad=${encodeURIComponent(pad)}` +
                            `&roi_thickness=${encodeURIComponent(thickness)}`;
                    }
                } catch (e) {}

                const url =
                    `/dicom-viewer/api/series/${currentSeries.id}/bone/` +
                    `?threshold=${encodeURIComponent(threshold)}` +
                    `&mesh=${encodeURIComponent(wantMesh ? 'true' : 'false')}` +
                    `&quality=${encodeURIComponent(meshQuality)}` +
                    `&window_width=${encodeURIComponent(2000)}` +
                    `&window_level=${encodeURIComponent(300)}` +
                    `&inverted=${encodeURIComponent(inverted ? 'true' : 'false')}` +
                    `${roiCropQs}`;

                const resp = await fetch(url, { credentials: 'same-origin' });
                const data = await resp.json();
                if (!resp.ok) {
                    const msg = data && (data.error || data.message) ? (data.error || data.message) : `HTTP ${resp.status}`;
                    throw new Error(msg);
                }

                // If mesh available + Three.js available, render true 3D.
                const mesh = data && data.mesh;
                if (mesh && Array.isArray(mesh.vertices) && Array.isArray(mesh.faces) && typeof THREE !== 'undefined') {
                    bone3D.vertices = mesh.vertices;
                    bone3D.faces = mesh.faces;
                    ensureBone3DInitialized();
                    renderBoneMesh(mesh.vertices, mesh.faces);
                    updateBoneMaterialOpacity();
                } else {
                    // Fallback: show an axial bone preview as a static image in the 3D pane.
                    const canvas = mprCanvases.bone3d;
                    const ctx = canvas.getContext('2d');
                    const views = data && (data.bone_views || data.views || {});
                    const imgUrl = views.axial || views.sagittal || views.coronal;
                    if (imgUrl) {
                        await _render2DIntoCanvas(canvas, ctx, imgUrl);
                    } else {
                        renderBonePlaceholder(ctx, canvas.width, canvas.height);
                    }
                }
            } catch (error) {
                console.error('Error generating bone reconstruction:', error);
                showToast(`Bone reconstruction failed: ${error?.message || error}`, 'error');
            } finally {
                showLoading(false);
            }
        }

        async function _render2DIntoCanvas(canvas, ctx, dataUrl) {
            const img = new Image();
            img.src = dataUrl;
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
            });
            const w = img.naturalWidth || img.width;
            const h = img.naturalHeight || img.height;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Avoid upscaling 2D fallbacks (prevents zoomed look on large panes).
            const scaleFit = Math.min(canvas.width / w, canvas.height / h);
            const scale = Math.min(1, scaleFit);
            const dw = Math.round(w * scale);
            const dh = Math.round(h * scale);
            const dx = Math.round((canvas.width - dw) / 2);
            const dy = Math.round((canvas.height - dh) / 2);
            ctx.imageSmoothingEnabled = scale < 1;
            try { ctx.imageSmoothingQuality = 'high'; } catch (e) {}
            ctx.drawImage(img, dx, dy, dw, dh);
        }

        function ensureBone3DInitialized() {
            const c = mprCanvases.bone3d;
            if (!c || typeof THREE === 'undefined') return;
            if (bone3D.renderer && bone3D.scene && bone3D.camera) return;

            bone3D.renderer = new THREE.WebGLRenderer({
                canvas: c,
                antialias: true,
                alpha: true,
                powerPreference: 'high-performance',
                preserveDrawingBuffer: true, // enables clean screenshots/exports
            });
            // IMPORTANT: our canvases are already sized in device pixels (backing store) using DPR.
            // So Three.js should render at pixelRatio=1, otherwise it double-applies DPR and looks zoomed/slow.
            bone3D.renderer.setPixelRatio(1);
            bone3D._lastW = 0;
            bone3D._lastH = 0;
            bone3D.renderer.setSize(c.width || 1, c.height || 1, false);
            try { bone3D.renderer.outputEncoding = THREE.sRGBEncoding; } catch (e) {}
            try { bone3D.renderer.toneMapping = THREE.ACESFilmicToneMapping; } catch (e) {}
            try { bone3D.renderer.toneMappingExposure = 1.1; } catch (e) {}
            try { bone3D.renderer.physicallyCorrectLights = true; } catch (e) {}
            bone3D.renderer.setClearColor(0x000000, 1);
            bone3D.renderer.shadowMap.enabled = true;
            bone3D.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            bone3D.scene = new THREE.Scene();
            bone3D.scene.background = new THREE.Color(0x000000);

            bone3D.camera = new THREE.PerspectiveCamera(45, (c.width || 1) / (c.height || 1), 0.1, 10000);
            bone3D.camera.position.set(0, 0, 200);

            // Lighting tuned for clinical bone look (clear depth/edges, no harsh burn-in)
            const ambient = new THREE.AmbientLight(0xffffff, 0.25);
            const hemi = new THREE.HemisphereLight(0xffffff, 0x222244, 0.35);
            const key = new THREE.DirectionalLight(0xffffff, 1.0);
            key.position.set(1.2, 1.0, 1.8);
            key.castShadow = true;
            key.shadow.mapSize.width = 2048;
            key.shadow.mapSize.height = 2048;
            key.shadow.camera.near = 0.1;
            key.shadow.camera.far = 2000;
            key.shadow.bias = -0.00005;

            const fill = new THREE.DirectionalLight(0xffffff, 0.35);
            fill.position.set(-1.5, 0.6, 0.8);

            const rim = new THREE.DirectionalLight(0x88aaff, 0.25);
            rim.position.set(0.0, -1.0, -1.2);

            bone3D.scene.add(ambient);
            bone3D.scene.add(hemi);
            bone3D.scene.add(key);
            bone3D.scene.add(fill);
            bone3D.scene.add(rim);

            // Shadow catcher (subtle)
            const shadowPlane = new THREE.Mesh(
                new THREE.PlaneGeometry(2000, 2000),
                new THREE.ShadowMaterial({ opacity: 0.18 })
            );
            shadowPlane.rotation.x = -Math.PI / 2;
            shadowPlane.position.y = -200;
            shadowPlane.receiveShadow = true;
            bone3D.scene.add(shadowPlane);

            // Smooth rotate/pan/zoom controls (no external OrbitControls dependency).
            bone3D.dragMode = null; // 'rotate' | 'pan'
            bone3D.targetRotX = 0;
            bone3D.targetRotY = 0;
            bone3D.targetZoom = 1.0;
            bone3D.panX = 0;
            bone3D.panY = 0;

            const _isPanGesture = (e) => (e.button === 1 || e.button === 2 || e.shiftKey);

            c.addEventListener('mousedown', (e) => {
                if (viewMode !== 'mpr') return;
                bone3D.dragging = true;
                bone3D.wasDragged = false;
                bone3D.dragMode = _isPanGesture(e) ? 'pan' : 'rotate';
                bone3D.lastX = e.clientX;
                bone3D.lastY = e.clientY;
            });
            window.addEventListener('mouseup', () => {
                bone3D.dragging = false;
                bone3D.dragMode = null;
            });
            window.addEventListener('mousemove', (e) => {
                if (!bone3D.dragging || !bone3D.mesh) return;
                const dx = e.clientX - bone3D.lastX;
                const dy = e.clientY - bone3D.lastY;
                bone3D.lastX = e.clientX;
                bone3D.lastY = e.clientY;
                if (Math.abs(dx) + Math.abs(dy) > 2) {
                    bone3D.wasDragged = true;
                }
                if (bone3D.dragMode === 'pan') {
                    // Pan in screen pixels; scaled to model size in render loop.
                    bone3D.panX += dx;
                    bone3D.panY -= dy;
                } else {
                    bone3D.targetRotY += dx * 0.01;
                    bone3D.targetRotX += dy * 0.01;
                }
            });
            c.addEventListener('wheel', (e) => {
                if (!bone3D.camera) return;
                e.preventDefault();
                const d = Math.sign(e.deltaY || 0);
                bone3D.targetZoom = Math.max(0.25, Math.min(6.0, (bone3D.targetZoom || 1.0) * (d > 0 ? 1.1 : 0.9)));
            }, { passive: false });
        }

        function renderBoneMesh(vertices, faces) {
            if (!bone3D.scene || !bone3D.renderer || !bone3D.camera) return;

            // Remove existing mesh
            if (bone3D.mesh) {
                bone3D.scene.remove(bone3D.mesh);
                try { bone3D.mesh.geometry?.dispose?.(); } catch (e) {}
                try { bone3D.mesh.material?.dispose?.(); } catch (e) {}
                bone3D.mesh = null;
            }

            const geom = new THREE.BufferGeometry();
            const pos = new Float32Array(vertices.length * 3);
            for (let i = 0; i < vertices.length; i++) {
                pos[i * 3 + 0] = vertices[i][0];
                pos[i * 3 + 1] = vertices[i][1];
                pos[i * 3 + 2] = vertices[i][2];
            }
            const idx = new Uint32Array(faces.length * 3);
            for (let i = 0; i < faces.length; i++) {
                idx[i * 3 + 0] = faces[i][0];
                idx[i * 3 + 1] = faces[i][1];
                idx[i * 3 + 2] = faces[i][2];
            }
            geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geom.setIndex(new THREE.BufferAttribute(idx, 1));
            geom.computeVertexNormals();
            geom.computeBoundingSphere();

            const mat = new THREE.MeshStandardMaterial({
                color: 0xf4f0e6, // warm bone
                transparent: true,
                opacity: Math.max(0.05, Math.min(1.0, Number(boneOpacity) || 0.8)),
                roughness: 0.38, // slightly crisper highlights to read surfaces
                metalness: 0.02,
                side: THREE.FrontSide,
            });
            const mesh = new THREE.Mesh(geom, mat);
            mesh.castShadow = true;
            mesh.receiveShadow = false;
            bone3D.mesh = mesh;
            bone3D.scene.add(mesh);

            // Fit camera
            geom.computeBoundingBox();
            const bb = geom.boundingBox;
            const size = new THREE.Vector3();
            bb.getSize(size);
            const center = new THREE.Vector3();
            bb.getCenter(center);
            mesh.position.sub(center);
            const maxDim = Math.max(size.x, size.y, size.z) || 1;
            const dist = maxDim * 1.35;
            bone3D.camera.near = Math.max(0.01, dist / 100);
            bone3D.camera.far = dist * 20;
            bone3D.camera.position.set(dist * 0.15, dist * 0.12, dist);
            bone3D.camera.lookAt(0, 0, 0);
            bone3D.camera.zoom = bone3D.zoom = bone3D.targetZoom = 1.0;
            bone3D.camera.updateProjectionMatrix();
            bone3D.rotX = 0;
            bone3D.rotY = 0;
            bone3D.targetRotX = 0;
            bone3D.targetRotY = 0;
            bone3D.panX = 0;
            bone3D.panY = 0;
            mesh.rotation.set(0, 0, 0);
            // Store fit for resets
            bone3D.fitDist = dist;

            renderBoneFrame();
            startBoneAnimationLoop();
        }

        function updateBoneMaterialOpacity() {
            if (bone3D.mesh && bone3D.mesh.material) {
                bone3D.mesh.material.opacity = Math.max(0.05, Math.min(1.0, Number(boneOpacity) || 0.8));
                bone3D.mesh.material.needsUpdate = true;
                renderBoneFrame();
            }
        }

        function renderBoneFrame() {
            const c = mprCanvases.bone3d;
            if (!c || !bone3D.renderer || !bone3D.scene || !bone3D.camera) return;
            // Keep renderer in sync with canvas size
            const w = c.width || 1;
            const h = c.height || 1;
            if (bone3D._lastW !== w || bone3D._lastH !== h) {
                bone3D._lastW = w;
                bone3D._lastH = h;
                bone3D.renderer.setSize(w, h, false);
                bone3D.camera.aspect = w / h;
                bone3D.camera.updateProjectionMatrix();
            }
            bone3D.renderer.render(bone3D.scene, bone3D.camera);
        }

        function startBoneAnimationLoop() {
            if (bone3D.animRaf) return;
            const tick = () => {
                bone3D.animRaf = requestAnimationFrame(tick);
                if (!bone3D.mesh) return;

                // Apply damping for smooth interaction
                const damp = 0.18;
                bone3D.rotX += (Number(bone3D.targetRotX || 0) - Number(bone3D.rotX || 0)) * damp;
                bone3D.rotY += (Number(bone3D.targetRotY || 0) - Number(bone3D.rotY || 0)) * damp;
                bone3D.zoom += (Number(bone3D.targetZoom || 1.0) - Number(bone3D.zoom || 1.0)) * damp;

                bone3D.mesh.rotation.y = bone3D.rotY;
                bone3D.mesh.rotation.x = bone3D.rotX;

                // Pan: map pixels -> world units based on fitted model distance.
                const c = mprCanvases.bone3d;
                const w = (c && c.width) ? c.width : 1;
                const h = (c && c.height) ? c.height : 1;
                const dist = Number(bone3D.fitDist || 200);
                const panScale = dist / 800; // heuristic
                bone3D.mesh.position.x = (Number(bone3D.panX || 0) / w) * (dist * panScale);
                bone3D.mesh.position.y = (Number(bone3D.panY || 0) / h) * (dist * panScale);

                if (bone3D.camera) {
                    bone3D.camera.zoom = Math.max(0.25, Math.min(6.0, Number(bone3D.zoom || 1.0)));
                    bone3D.camera.updateProjectionMatrix();
                }

                if (autoRotate) {
                    bone3D.targetRotY += 0.01;
                }
                renderBoneFrame();
            };
            bone3D.animRaf = requestAnimationFrame(tick);
        }

        function stopBoneAnimationLoop() {
            if (bone3D.animRaf) {
                cancelAnimationFrame(bone3D.animRaf);
                bone3D.animRaf = null;
            }
        }

        function renderBonePlaceholder(ctx, width, height) {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Draw a simple 3D-like bone structure placeholder
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
            
            // Draw simple bone-like shapes
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Main bone shaft
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, 60, 120, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Bone ends (epiphyses)
            ctx.beginPath();
            ctx.ellipse(centerX, centerY - 100, 40, 25, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            ctx.beginPath();
            ctx.ellipse(centerX, centerY + 100, 40, 25, 0, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Add text overlay
            ctx.fillStyle = 'var(--accent-color)';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('3D Bone Reconstruction', centerX, 30);
            ctx.fillStyle = '#ccc';
            ctx.font = '12px Arial';
            ctx.fillText(`Threshold: ${boneThreshold} HU`, centerX, height - 40);
            ctx.fillText(`Opacity: ${boneOpacity}`, centerX, height - 20);
        }

        async function generateMIP() {
            if (!currentSeries) return;
            
            try {
                showLoading(true);
                if (viewMode === 'single') {
                    // Switch layout so results are visible
                    const singleView = document.getElementById('singleView');
                    const mprView = document.getElementById('mprView');
                    const controls3D = document.getElementById('controls3D');
                    if (singleView) singleView.style.display = 'none';
                    if (mprView) mprView.classList.add('active');
                    if (controls3D) controls3D.style.display = 'block';
                    viewMode = 'mpr';
                    setMPRMaximizedPlane(null);
                    setActiveMPRPlane('axial');
                }
                try { resizeCanvas(); } catch (e) {}
                const qs = `window_width=${encodeURIComponent(windowWidth)}&window_level=${encodeURIComponent(windowLevel)}&inverted=${encodeURIComponent(inverted)}`;
                const response = await fetch(`/dicom-viewer/api/series/${currentSeries.id}/mip/?${qs}`, { credentials: 'same-origin' });
                const data = await response.json();
                if (!response.ok) {
                    const msg = data && (data.error || data.message) ? (data.error || data.message) : `HTTP ${response.status}`;
                    throw new Error(msg);
                }

                const views = data && (data.mip_views || data.views || data.mipViews);
                if (!views || (!views.axial && !views.sagittal && !views.coronal)) {
                    throw new Error('Unexpected MIP response');
                }
                await Promise.allSettled([
                    _renderMPRDataUrl('axial', views.axial),
                    _renderMPRDataUrl('sagittal', views.sagittal),
                    _renderMPRDataUrl('coronal', views.coronal),
                ]);
                showToast('MIP ready', 'success');
            } catch (error) {
                console.error('Error generating MIP:', error);
                showToast(`Failed to generate MIP: ${error?.message || error}`, 'error');
            } finally {
                showLoading(false);
            }
        }

        function toggleSmoothing(enabled) {
            smoothSurface = enabled;
            if (viewMode === 'mpr') {
                generateBoneReconstruction();
            }
        }

        // 3D Control Functions
        function reset3DView() {
            if (bone3D && bone3D.mesh) {
                bone3D.rotX = 0;
                bone3D.rotY = 0;
                bone3D.targetRotX = 0;
                bone3D.targetRotY = 0;
                bone3D.zoom = bone3D.targetZoom = 1.0;
                bone3D.panX = 0;
                bone3D.panY = 0;
                bone3D.mesh.position.set(0, 0, 0);
                bone3D.mesh.rotation.set(0, 0, 0);
                if (bone3D.camera) {
                    bone3D.camera.zoom = 1.0;
                    bone3D.camera.updateProjectionMatrix();
                }
                renderBoneFrame();
                showToast('3D view reset', 'success');
            } else {
                generateBoneReconstruction();
            }
        }

        function toggle3DRotation() {
            autoRotate = !autoRotate;
            if (autoRotate) {
                startBoneAnimationLoop();
                showToast('Auto-rotate enabled', 'success');
            } else {
                // Stop the loop only if we don't have a mesh; otherwise keep it for responsiveness
                if (!bone3D || !bone3D.mesh) stopBoneAnimationLoop();
                showToast('Auto-rotate disabled', 'success');
            }
        }

        function export3DModel() {
            try {
                const verts = bone3D && bone3D.vertices;
                const faces = bone3D && bone3D.faces;
                if (!verts || !faces || !Array.isArray(verts) || !Array.isArray(faces) || verts.length === 0 || faces.length === 0) {
                    showToast('No 3D mesh to export', 'warning');
                    return;
                }
                let obj = `o bone_reconstruction\n`;
                for (const v of verts) {
                    obj += `v ${v[0]} ${v[1]} ${v[2]}\n`;
                }
                for (const f of faces) {
                    // OBJ is 1-based indexing
                    obj += `f ${f[0] + 1} ${f[1] + 1} ${f[2] + 1}\n`;
                }
                const blob = new Blob([obj], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `bone_${currentSeries?.id || 'series'}_${Date.now()}.obj`;
                a.click();
                URL.revokeObjectURL(url);
                showToast('Exported 3D model (.obj)', 'success');
            } catch (e) {
                showToast(`Export failed: ${e?.message || e}`, 'error');
            }
        }

        // Print and Export Functions
        function printCurrentImage() {
            if (!canvas) return;
            
            const printWindow = window.open('', '_blank');
            const imageDataUrl = canvas.toDataURL('image/png');
            
            printWindow.document.write(`
                <html>
                    <head><title>DICOM Image Print</title></head>
                    <body style="margin:0; display:flex; justify-content:center; align-items:center; min-height:100vh;">
                        <img src="${imageDataUrl}" style="max-width:100%; max-height:100%;" />
                    </body>
                </html>
            `);
            
            printWindow.document.close();
            printWindow.focus();
            
            setTimeout(() => {
                printWindow.print();
                printWindow.close();
            }, 250);
            
            showToast('Print dialog opened', 'success');
        }

        function exportCurrentImage() {
            if (!canvas) return;
            
            const link = document.createElement('a');
            link.download = `dicom_image_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            
            showToast('Image exported', 'success');
        }

        // Utility Functions
        function showLoading(show) {
            const indicator = document.getElementById('loadingIndicator');
            indicator.style.display = show ? 'flex' : 'none';
        }

        function showToast(message, type = 'info', duration = 3000) {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icon = type === 'success' ? 'check' : 
                        type === 'error' ? 'exclamation-triangle' : 
                        type === 'warning' ? 'exclamation-circle' : 'info-circle';
            
            toast.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <i class="fas fa-${icon}"></i>
                    <span>${message}</span>
                </div>
            `;
            
            document.body.appendChild(toast);
            
            // Show toast
            setTimeout(() => toast.classList.add('show'), 10);
            
            // Hide and remove toast
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.remove();
                    }
                }, 300);
            }, duration);
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // Auto-save session state periodically
        setInterval(async function() {
            if (currentStudy) {
                try {
                    await fetch('/dicom-viewer/session/save/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken')
                        },
                        body: JSON.stringify({
                            study_id: currentStudy.id,
                            session_data: JSON.stringify({
                                current_image_index: currentImageIndex,
                                window_width: windowWidth,
                                window_level: windowLevel,
                                zoom: zoom,
                                pan_x: panX,
                                pan_y: panY,
                                inverted: inverted,
                                rotation: rotation,
                                flip_h: flipH,
                                flip_v: flipV,
                                view_mode: viewMode,
                                bone_threshold: boneThreshold,
                                bone_opacity: boneOpacity
                            })
                        })
                    });
                } catch (error) {
                    console.error('Error saving session state:', error);
                }
            }
        }, 30000); // Save every 30 seconds

        // Directory Loader Functions
        function showDirectoryLoader() {
            if (!DIRECTORY_IMPORT_ENABLED) {
                showToast('Directory import is disabled on this server', 'warning');
                return;
            }
            document.getElementById('directoryModal').style.display = 'flex';
        }

        function hideDirectoryLoader() {
            document.getElementById('directoryModal').style.display = 'none';
        }

        async function loadFromDirectory() {
            if (!DIRECTORY_IMPORT_ENABLED) {
                showToast('Directory import is disabled on this server', 'warning');
                return;
            }
            const directoryPath = document.getElementById('directoryPath').value.trim();
            if (!directoryPath) {
                showToast('Please enter a directory path', 'error');
                return;
            }

            try {
                showLoading(true);
                hideDirectoryLoader();
                
                const formData = new FormData();
                formData.append('directory_path', directoryPath);

                const response = await fetch('/dicom-viewer/load-directory/', {
                    method: 'POST',
                    body: formData,
                    headers: {
                        'X-CSRFToken': (document.querySelector('meta[name="csrf-token"]') && document.querySelector('meta[name="csrf-token"]').getAttribute('content')) || ''
                    }
                });

                const result = await response.json();
                
                if (result.success) {
                    showToast(`Successfully loaded ${result.processed_files} DICOM files`, 'success');
                    // Refresh the studies list
                    loadStudies();
                } else {
                    showToast(`Failed to load directory: ${result.error}`, 'error');
                }
                
            } catch (error) {
                console.error('Error loading directory:', error);
                showToast('Failed to load directory', 'error');
            } finally {
                showLoading(false);
            }
        }

        // Add keyboard shortcut for directory loader
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey && e.key === 'o') {
                e.preventDefault();
                showDirectoryLoader();
            }
            if (e.key === 'Escape') {
                hideDirectoryLoader();
            }
        });
    </script>

    <!-- Directory Loader Modal -->
    <div id="directoryModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 10000; justify-content: center; align-items: center;">
        <div style="background: var(--card-bg); padding: 30px; border-radius: 12px; border: 1px solid var(--border-color); max-width: 500px; width: 90%;">
            <h3 style="color: var(--text-primary); margin-bottom: 20px; text-align: center;">
                <i class="fas fa-folder-open"></i> Load DICOM Directory
            </h3>
            <p style="color: var(--text-secondary); margin-bottom: 20px; font-size: 14px;">
                Enter the full path to a directory containing DICOM files. The system will recursively scan for DICOM files.
            </p>
            <div style="margin-bottom: 20px;">
                <label style="display: block; color: var(--text-secondary); margin-bottom: 8px; font-size: 14px;">Directory Path:</label>
                <input type="text" id="directoryPath" placeholder="/path/to/dicom/directory" 
                       style="width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--secondary-bg); color: var(--text-primary); font-family: monospace;">
            </div>
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button onclick="hideDirectoryLoader()" 
                        style="padding: 10px 20px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--secondary-bg); color: var(--text-secondary); cursor: pointer;">
                    Cancel
                </button>
                <button onclick="loadFromDirectory()" 
                        style="padding: 10px 20px; border: none; border-radius: 6px; background: var(--accent-color); color: white; cursor: pointer;">
                    <i class="fas fa-folder-open"></i> Load Directory
                </button>
            </div>
            <div style="margin-top: 15px; padding: 10px; background: var(--secondary-bg); border-radius: 6px; font-size: 12px; color: var(--text-muted);">
                <strong>Examples:</strong><br>
                 /media/usb/dicom_studies/<br>
                 /mnt/cdrom/DICOM/<br>
                 /home/user/Downloads/patient_study/<br>
                <br>
                <strong>Tip:</strong> Use Ctrl+O to quickly open this dialog
            </div>
        </div>
    </div>
</body>
</html>